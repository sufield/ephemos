
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ephemos-cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sufield/ephemos/cmd/ephemos-cli/main.go (0.0%)</option>
				
				<option value="file1">github.com/sufield/ephemos/examples/echo-client/main.go (0.0%)</option>
				
				<option value="file2">github.com/sufield/ephemos/examples/echo-server/main.go (0.0%)</option>
				
				<option value="file3">github.com/sufield/ephemos/examples/enhanced-connection-management/main.go (0.0%)</option>
				
				<option value="file4">github.com/sufield/ephemos/examples/interceptors/main.go (0.0%)</option>
				
				<option value="file5">github.com/sufield/ephemos/examples/proto/client.go (0.0%)</option>
				
				<option value="file6">github.com/sufield/ephemos/examples/proto/echo.pb.go (0.0%)</option>
				
				<option value="file7">github.com/sufield/ephemos/examples/proto/echo_grpc.pb.go (0.0%)</option>
				
				<option value="file8">github.com/sufield/ephemos/examples/proto/registrar.go (0.0%)</option>
				
				<option value="file9">github.com/sufield/ephemos/internal/adapters/interceptors/auth.go (84.7%)</option>
				
				<option value="file10">github.com/sufield/ephemos/internal/adapters/interceptors/identity_propagation.go (87.5%)</option>
				
				<option value="file11">github.com/sufield/ephemos/internal/adapters/interceptors/logging.go (91.5%)</option>
				
				<option value="file12">github.com/sufield/ephemos/internal/adapters/interceptors/metrics.go (48.3%)</option>
				
				<option value="file13">github.com/sufield/ephemos/internal/adapters/logging/redactor.go (76.3%)</option>
				
				<option value="file14">github.com/sufield/ephemos/internal/adapters/primary/api/client.go (27.3%)</option>
				
				<option value="file15">github.com/sufield/ephemos/internal/adapters/primary/api/server.go (25.9%)</option>
				
				<option value="file16">github.com/sufield/ephemos/internal/adapters/primary/api/test_helpers.go (0.0%)</option>
				
				<option value="file17">github.com/sufield/ephemos/internal/adapters/primary/cli/registrar.go (75.3%)</option>
				
				<option value="file18">github.com/sufield/ephemos/internal/adapters/secondary/config/inmemory_provider.go (0.0%)</option>
				
				<option value="file19">github.com/sufield/ephemos/internal/adapters/secondary/config/provider.go (85.7%)</option>
				
				<option value="file20">github.com/sufield/ephemos/internal/adapters/secondary/memidentity/provider.go (62.1%)</option>
				
				<option value="file21">github.com/sufield/ephemos/internal/adapters/secondary/spiffe/provider.go (14.9%)</option>
				
				<option value="file22">github.com/sufield/ephemos/internal/adapters/secondary/transport/connection_config.go (100.0%)</option>
				
				<option value="file23">github.com/sufield/ephemos/internal/adapters/secondary/transport/grpc_transport.go (1.7%)</option>
				
				<option value="file24">github.com/sufield/ephemos/internal/app/configuration.go (0.0%)</option>
				
				<option value="file25">github.com/sufield/ephemos/internal/app/errors.go (0.0%)</option>
				
				<option value="file26">github.com/sufield/ephemos/internal/app/identity_service.go (0.0%)</option>
				
				<option value="file27">github.com/sufield/ephemos/internal/cli/register.go (8.3%)</option>
				
				<option value="file28">github.com/sufield/ephemos/internal/cli/root.go (25.0%)</option>
				
				<option value="file29">github.com/sufield/ephemos/internal/contract/configurationprovider/suite.go (0.0%)</option>
				
				<option value="file30">github.com/sufield/ephemos/internal/contract/identityprovider/suite.go (0.0%)</option>
				
				<option value="file31">github.com/sufield/ephemos/internal/contract/transportprovider/suite.go (0.0%)</option>
				
				<option value="file32">github.com/sufield/ephemos/internal/core/domain/identity.go (28.6%)</option>
				
				<option value="file33">github.com/sufield/ephemos/internal/core/errors/errors.go (100.0%)</option>
				
				<option value="file34">github.com/sufield/ephemos/internal/core/ports/configuration.go (72.3%)</option>
				
				<option value="file35">github.com/sufield/ephemos/internal/core/services/identity_service.go (0.0%)</option>
				
				<option value="file36">github.com/sufield/ephemos/internal/domain/identity.go (0.0%)</option>
				
				<option value="file37">github.com/sufield/ephemos/internal/infra/cli/register.go (8.3%)</option>
				
				<option value="file38">github.com/sufield/ephemos/internal/infra/cli/registrar.go (0.0%)</option>
				
				<option value="file39">github.com/sufield/ephemos/internal/infra/cli/root.go (25.0%)</option>
				
				<option value="file40">github.com/sufield/ephemos/internal/infra/config/inmemory_provider.go (0.0%)</option>
				
				<option value="file41">github.com/sufield/ephemos/internal/infra/config/provider.go (0.0%)</option>
				
				<option value="file42">github.com/sufield/ephemos/internal/infra/grpc/client.go (0.0%)</option>
				
				<option value="file43">github.com/sufield/ephemos/internal/infra/grpc/server.go (0.0%)</option>
				
				<option value="file44">github.com/sufield/ephemos/internal/infra/grpc/test_helpers.go (0.0%)</option>
				
				<option value="file45">github.com/sufield/ephemos/internal/infra/spiffe/provider.go (0.0%)</option>
				
				<option value="file46">github.com/sufield/ephemos/pkg/ephemos/ephemos.go (4.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the Ephemos CLI tool for production SPIFFE/SPIRE service management
// and identity-based authentication administration.
//
// The ephemos CLI tool is a production utility for system administrators,
// DevOps engineers, and developers managing Ephemos-based services in
// development and production environments.
//
// Core functionality includes:
//   - Service registration with SPIRE server
//   - Configuration validation and management
//   - Identity verification and diagnostics
//   - SPIRE infrastructure health checks
//   - Certificate and trust bundle inspection
//   - Service selector management
//
// Usage:
//
//        ephemos register --config config.yaml --selector unix:user:1000
//        ephemos validate --config config.yaml
//        ephemos health --config config.yaml --verbose
//
// The tool integrates with SPIRE infrastructure to provide streamlined
// service identity management for microservices and distributed systems.
// It abstracts SPIFFE/SPIRE complexity while providing full administrative
// control over identity policies and service registration.
//
// This is a production CLI binary built from cmd/ephemos-cli according to
// Go project layout conventions for production command-line tools.
package main

import (
        "fmt"
        "os"

        "github.com/sufield/ephemos/internal/cli"
)

// main is the entry point for the Ephemos CLI tool.
// It executes the root command and handles any errors that occur.
func main() <span class="cov0" title="0">{
        if err := cli.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "time"

        "github.com/sufield/ephemos/examples/proto"
        "github.com/sufield/ephemos/internal/adapters/logging"
        "github.com/sufield/ephemos/pkg/ephemos"
)

func main() <span class="cov0" title="0">{
        // Setup secure structured logging with debug level for troubleshooting
        baseHandler := slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })
        secureLogger := logging.NewSecureLogger(baseHandler)
        slog.SetDefault(secureLogger)

        ctx := context.Background()

        // Create identity-aware client
        client, err := ephemos.NewIdentityClient(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create identity client", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Failed to close client", "error", err)
                }</span>
        }()

        // Connect to the echo server
        <span class="cov0" title="0">conn, err := client.Connect(ctx, "echo-server", "localhost:50052")
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to connect to echo server", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Failed to close connection", "error", err)
                }</span>
        }()

        // Create echo service client using the generic wrapper
        <span class="cov0" title="0">echoClient, err := proto.NewEchoClient(conn.GetClientConnection())
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create echo client", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := echoClient.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Failed to close echo client", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">slog.Info("Connected to echo server", "address", "localhost:50052")

        // Make echo requests
        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                // Create request context with timeout
                reqCtx, cancel := context.WithTimeout(ctx, 5*time.Second)

                message := fmt.Sprintf("Hello from echo-client! Request #%d", i+1)
                resp, err := echoClient.Echo(reqCtx, message)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Echo request failed", "request", i+1, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        slog.Info("Echo response received",
                                "request", i+1,
                                "message", resp.Message,
                                "from", resp.From)
                }</span>

                <span class="cov0" title="0">cancel() // Clean up the timeout context
                time.Sleep(2 * time.Second)</span>
        }

        <span class="cov0" title="0">slog.Info("Echo client completed successfully")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "net"
        "os"
        "os/signal"
        "syscall"
        "time"

        "google.golang.org/grpc"

        "github.com/sufield/ephemos/examples/proto"
        "github.com/sufield/ephemos/internal/adapters/logging"
        "github.com/sufield/ephemos/pkg/ephemos"
)

// EchoServer implements the EchoServiceServer interface.
// This is an example implementation that developers can use as reference
// when building their own services with the Ephemos library.
type EchoServer struct {
        proto.UnimplementedEchoServiceServer
}

// Echo implements the Echo method of the EchoServiceServer interface.
// This is the actual business logic of the service.
func (s *EchoServer) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.EchoResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request cannot be nil")
        }</span>

        <span class="cov0" title="0">slog.Info("Processing echo request", "message", req.Message)

        return &amp;proto.EchoResponse{
                Message: req.Message,
                From:    "echo-server",
        }, nil</span>
}

func main() <span class="cov0" title="0">{
        // Create cancellable context for graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Setup secure structured logging with debug level for troubleshooting
        baseHandler := slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })
        secureLogger := logging.NewSecureLogger(baseHandler)
        slog.SetDefault(secureLogger)

        // Get server configuration
        serverConfig, err := getServerConfig()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to get server config", "error", err)
                os.Exit(1)
        }</span>

        // Create identity-aware server with context
        <span class="cov0" title="0">server, err := createIdentityServer(ctx, serverConfig)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create identity server", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := server.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Failed to close server", "error", err)
                }</span>
        }()

        // Register service using the generic registrar (no boilerplate required)
        <span class="cov0" title="0">serviceRegistrar := ephemos.NewServiceRegistrar(func(s *grpc.Server) </span><span class="cov0" title="0">{
                proto.RegisterEchoServiceServer(s, &amp;EchoServer{})
        }</span>)

        <span class="cov0" title="0">if err := server.RegisterService(ctx, serviceRegistrar); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to register service", "error", err)
                os.Exit(1)
        }</span>

        // Setup listener with cleanup
        <span class="cov0" title="0">lis, err := net.Listen("tcp", serverConfig.Address)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to listen", "address", serverConfig.Address, "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := lis.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Failed to close listener", "error", err)
                }</span>
        }()

        // Setup graceful shutdown
        <span class="cov0" title="0">shutdownChan := make(chan os.Signal, 1)
        signal.Notify(shutdownChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-shutdownChan
                slog.Info("Shutdown signal received, stopping server gracefully")
                cancel()
        }</span>()

        <span class="cov0" title="0">slog.Info("Echo server starting", "address", serverConfig.Address, "service", "echo-server")

        // Serve with context for cancellation
        serveCtx, serveCancel := context.WithTimeout(ctx, 30*time.Second)
        defer serveCancel()

        if err := server.Serve(serveCtx, lis); err != nil </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        slog.Info("Server stopped gracefully")
                }</span> else<span class="cov0" title="0"> {
                        slog.Error("Server failed", "error", err)
                        os.Exit(1)
                }</span>
        }
}

type ServerConfig struct {
        Address    string
        ConfigPath string
}

func getServerConfig() (*ServerConfig, error) <span class="cov0" title="0">{
        address := os.Getenv("ECHO_SERVER_ADDRESS")
        if address == "" </span><span class="cov0" title="0">{
                address = ":50051" // Default fallback
        }</span>

        <span class="cov0" title="0">configPath := os.Getenv("EPHEMOS_CONFIG")

        return &amp;ServerConfig{
                Address:    address,
                ConfigPath: configPath,
        }, nil</span>
}

func createIdentityServer(ctx context.Context, config *ServerConfig) (ephemos.Server, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server config cannot be nil")
        }</span>

        <span class="cov0" title="0">server, err := ephemos.NewIdentityServer(ctx, config.ConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create identity server: %w", err)
        }</span>

        <span class="cov0" title="0">return server, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package main demonstrates advanced gRPC connection management features in ephemos.
package main

import (
        "fmt"
        "time"

        "github.com/sufield/ephemos/internal/adapters/secondary/spiffe"
        "github.com/sufield/ephemos/internal/adapters/secondary/transport"
)

func main() <span class="cov0" title="0">{
        fmt.Println("Enhanced gRPC Connection Management Example")
        fmt.Println("==========================================")

        // Example 1: Default Production Configuration
        fmt.Println("\n1. Default Production Configuration:")
        defaultConfig := transport.DefaultConnectionConfig()
        printConnectionConfig("Default", defaultConfig)

        // Example 2: Development Configuration (faster timeouts, fewer retries)
        fmt.Println("\n2. Development Configuration:")
        devConfig := transport.DevelopmentConnectionConfig()
        printConnectionConfig("Development", devConfig)

        // Example 3: High-Throughput Configuration (optimized for performance)
        fmt.Println("\n3. High-Throughput Configuration:")
        highThroughputConfig := transport.HighThroughputConnectionConfig()
        printConnectionConfig("High-Throughput", highThroughputConfig)

        // Example 4: Custom Configuration
        fmt.Println("\n4. Custom Configuration Example:")
        customConfig := createCustomConfig()
        printConnectionConfig("Custom", customConfig)

        // Example 5: Using the enhanced provider
        fmt.Println("\n5. Creating Enhanced gRPC Provider:")
        demonstrateProviderUsage()

        fmt.Println("\nDemonstration completed!")
}</span>

func printConnectionConfig(name string, config *transport.ConnectionConfig) <span class="cov0" title="0">{
        fmt.Printf("  %s Configuration:\n", name)
        fmt.Printf("    - Connect Timeout: %v\n", config.ConnectTimeout)
        fmt.Printf("    - Backoff Base Delay: %v\n", config.BackoffConfig.BaseDelay)
        fmt.Printf("    - Backoff Max Delay: %v\n", config.BackoffConfig.MaxDelay)
        fmt.Printf("    - Backoff Multiplier: %.2f\n", config.BackoffConfig.Multiplier)
        fmt.Printf("    - Backoff Jitter: %.2f\n", config.BackoffConfig.Jitter)
        fmt.Printf("    - Keepalive Time: %v\n", config.KeepaliveParams.Time)
        fmt.Printf("    - Keepalive Timeout: %v\n", config.KeepaliveParams.Timeout)
        fmt.Printf("    - Keepalive Without Stream: %v\n", config.KeepaliveParams.PermitWithoutStream)
        fmt.Printf("    - Idle Timeout: %v\n", config.IdleTimeout)
        fmt.Printf("    - Max Recv Message Size: %d MB\n", config.MaxRecvMsgSize/(1024*1024))
        fmt.Printf("    - Max Send Message Size: %d MB\n", config.MaxSendMsgSize/(1024*1024))
        fmt.Printf("    - Connection Pooling: %v\n", config.EnablePooling)
        if config.EnablePooling </span><span class="cov0" title="0">{
                fmt.Printf("    - Pool Size: %d\n", config.PoolSize)
        }</span>
        <span class="cov0" title="0">fmt.Printf("    - Service Config Contains Retry Policy: %v\n",
                len(config.ServiceConfig) &gt; 0 &amp;&amp; contains(config.ServiceConfig, "retryPolicy"))</span>
}

func createCustomConfig() *transport.ConnectionConfig <span class="cov0" title="0">{
        // Create a custom configuration for a specific use case:
        // - Microservice with moderate traffic
        // - Needs resilience but not extreme performance
        // - Deployed in a reliable network environment

        config := transport.DefaultConnectionConfig()

        // Adjust timeouts for moderate traffic scenario
        config.ConnectTimeout = 15 * time.Second

        // Configure more aggressive backoff for faster recovery
        config.BackoffConfig.BaseDelay = 500 * time.Millisecond
        config.BackoffConfig.Multiplier = 2.0
        config.BackoffConfig.MaxDelay = 30 * time.Second

        // Adjust keepalive for moderate traffic
        config.KeepaliveParams.Time = 20 * time.Second
        config.KeepaliveParams.Timeout = 5 * time.Second

        // Enable pooling with moderate pool size
        config.EnablePooling = true
        config.PoolSize = 3

        // Set reasonable message sizes (8MB)
        config.MaxRecvMsgSize = 8 * 1024 * 1024
        config.MaxSendMsgSize = 8 * 1024 * 1024

        // Custom service configuration with moderate retry policy
        config.ServiceConfig = `{
                "methodConfig": [
                        {
                                "name": [{"service": ""}],
                                "retryPolicy": {
                                        "maxAttempts": 4,
                                        "initialBackoff": "1s",
                                        "maxBackoff": "15s",
                                        "backoffMultiplier": 1.8,
                                        "retryableStatusCodes": ["UNAVAILABLE", "DEADLINE_EXCEEDED"]
                                },
                                "timeout": "30s"
                        }
                ]
        }`

        return config
}</span>

func demonstrateProviderUsage() <span class="cov0" title="0">{
        // Create a mock SPIFFE provider (in real usage, this would be properly initialized)
        spiffeProvider := &amp;spiffe.Provider{}

        // Example 1: Default provider
        fmt.Println("  Creating default provider...")
        _ = transport.NewGRPCProvider(spiffeProvider)
        fmt.Println("    ✓ Default provider created with standard configuration")

        // Example 2: Development provider
        fmt.Println("  Creating development provider...")
        devConfig := transport.DevelopmentConnectionConfig()
        _ = transport.NewGRPCProviderWithConfig(spiffeProvider, devConfig)
        fmt.Println("    ✓ Development provider created with fast timeouts")

        // Example 3: High-throughput provider
        fmt.Println("  Creating high-throughput provider...")
        htConfig := transport.HighThroughputConnectionConfig()
        _ = transport.NewGRPCProviderWithConfig(spiffeProvider, htConfig)
        fmt.Println("    ✓ High-throughput provider created with connection pooling")

        // Example 4: Custom provider
        fmt.Println("  Creating custom provider...")
        customConfig := createCustomConfig()
        _ = transport.NewGRPCProviderWithConfig(spiffeProvider, customConfig)
        fmt.Println("    ✓ Custom provider created with tailored configuration")

        // Demonstrate configuration differences
        defaultConfig := transport.DefaultConnectionConfig()
        fmt.Println("\n  Configuration Comparison:")
        fmt.Printf("    Default connect timeout: %v\n", defaultConfig.ConnectTimeout)
        fmt.Printf("    Development connect timeout: %v\n", devConfig.ConnectTimeout)
        fmt.Printf("    High-throughput pooling: %v\n", htConfig.EnablePooling)
        fmt.Printf("    Custom pool size: %d\n", customConfig.PoolSize)
}</span>

// Note: In a real implementation, you would access configuration through provider methods
// This example demonstrates the configuration concepts and usage patterns

func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr ||
                (len(s) &gt; len(substr) &amp;&amp; (s[:len(substr)] == substr ||
                        s[len(s)-len(substr):] == substr ||
                        fmt.Sprintf("%s", s)[0:0] != fmt.Sprintf("%s", substr)[0:0]))) // simplified contains check
}</span>

// Additional examples of specific use cases

func demonstrateUseCase(name string, config *transport.ConnectionConfig, description string) <span class="cov0" title="0">{
        fmt.Printf("\n=== %s ===\n", name)
        fmt.Println(description)
        fmt.Println()

        // Show key configuration aspects for this use case
        fmt.Printf("Key Configuration:\n")
        fmt.Printf("- Connection Timeout: %v\n", config.ConnectTimeout)
        fmt.Printf("- Retry Max Attempts: Configured in service config\n")
        fmt.Printf("- Connection Pooling: %v\n", config.EnablePooling)
        if config.EnablePooling </span><span class="cov0" title="0">{
                fmt.Printf("- Pool Size: %d connections\n", config.PoolSize)
        }</span>
        <span class="cov0" title="0">fmt.Printf("- Max Message Size: %d MB\n", config.MaxRecvMsgSize/(1024*1024))</span>
}

func init() <span class="cov0" title="0">{
        // Additional use case examples
        go func() </span><span class="cov0" title="0">{
                time.Sleep(100 * time.Millisecond)

                // E-commerce example
                ecommerceConfig := transport.HighThroughputConnectionConfig()
                ecommerceConfig.ConnectTimeout = 5 * time.Second // Fast connection required
                demonstrateUseCase("E-commerce Platform",
                        ecommerceConfig,
                        "High-volume e-commerce platform requiring fast connections and high throughput for order processing and inventory updates.")

                // Financial services example
                financeConfig := transport.DefaultConnectionConfig()
                financeConfig.BackoffConfig.MaxDelay = 10 * time.Second // Conservative backoff
                financeConfig.IdleTimeout = 5 * time.Minute             // Shorter idle timeout for security
                demonstrateUseCase("Financial Services",
                        financeConfig,
                        "Financial trading system requiring reliable connections with conservative retry policies and strict timeout controls.")

                // IoT example
                iotConfig := transport.DevelopmentConnectionConfig()
                iotConfig.KeepaliveParams.Time = 60 * time.Second // Less frequent keepalives
                iotConfig.MaxRecvMsgSize = 1024 * 1024            // Smaller messages
                iotConfig.MaxSendMsgSize = 1024 * 1024
                demonstrateUseCase("IoT Data Collection",
                        iotConfig,
                        "IoT sensor data collection system with many small messages and battery-conscious keepalive settings.")
        }</span>()
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package main demonstrates how to use built-in interceptors with ephemos.
// This example shows different interceptor configurations for various environments.
package main

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "time"

        "google.golang.org/grpc"

        "github.com/sufield/ephemos/examples/proto"
        "github.com/sufield/ephemos/internal/adapters/interceptors"
        "github.com/sufield/ephemos/internal/adapters/logging"
        "github.com/sufield/ephemos/pkg/ephemos"
)

// ExampleServer demonstrates interceptor usage.
type ExampleServer struct {
        proto.UnimplementedEchoServiceServer
}

// Echo implements the echo service with interceptor support.
func (s *ExampleServer) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.EchoResponse, error) <span class="cov0" title="0">{
        // Extract authenticated identity (if auth interceptor is enabled)
        if identity, ok := interceptors.GetIdentityFromContext(ctx); ok </span><span class="cov0" title="0">{
                slog.Info("Processing request from authenticated client",
                        "spiffe_id", identity.SPIFFEID,
                        "service", identity.ServiceName,
                        "message", req.Message)
        }</span>

        // Extract propagated identity information
        <span class="cov0" title="0">if requestID, ok := interceptors.GetRequestID(ctx); ok </span><span class="cov0" title="0">{
                slog.Info("Processing request", "request_id", requestID)
        }</span>

        <span class="cov0" title="0">if originalCaller, ok := interceptors.GetOriginalCaller(ctx); ok </span><span class="cov0" title="0">{
                slog.Info("Request originated from", "original_caller", originalCaller)
        }</span>

        <span class="cov0" title="0">return &amp;proto.EchoResponse{
                Message: fmt.Sprintf("Echo: %s", req.Message),
                From:    "interceptor-example-server",
        }, nil</span>
}

func main() <span class="cov0" title="0">{
        // Setup logging
        baseHandler := slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })
        secureLogger := logging.NewSecureLogger(baseHandler)
        slog.SetDefault(secureLogger)

        // Example 1: Production configuration with all interceptors
        fmt.Println("=== Production Configuration Example ===")
        runServerExample("production", ephemos.NewProductionInterceptorConfig("example-service"))

        // Example 2: Development configuration with relaxed auth
        fmt.Println("\n=== Development Configuration Example ===")
        runServerExample("development", ephemos.NewDevelopmentInterceptorConfig("example-service"))

        // Example 3: Custom configuration
        fmt.Println("\n=== Custom Configuration Example ===")
        runServerExample("custom", createCustomInterceptorConfig())
}</span>

func runServerExample(configType string, interceptorConfig *ephemos.InterceptorConfig) <span class="cov0" title="0">{
        ctx := context.Background()

        // Create identity server
        server, err := ephemos.NewIdentityServer(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create server", "config_type", configType, "error", err)
                return
        }</span>
        <span class="cov0" title="0">defer server.Close()

        // Register service with interceptors
        serviceRegistrar := ephemos.NewServiceRegistrar(func(s *grpc.Server) </span><span class="cov0" title="0">{
                proto.RegisterEchoServiceServer(s, &amp;ExampleServer{})
        }</span>)

        <span class="cov0" title="0">if err := server.RegisterService(ctx, serviceRegistrar); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to register service", "config_type", configType, "error", err)
                return
        }</span>

        <span class="cov0" title="0">slog.Info("Server configured successfully",
                "config_type", configType,
                "auth_enabled", interceptorConfig.EnableAuth,
                "logging_enabled", interceptorConfig.EnableLogging,
                "metrics_enabled", interceptorConfig.EnableMetrics,
                "identity_propagation_enabled", interceptorConfig.EnableIdentityPropagation)</span>

        // In a real application, you would start the server here:
        // lis, _ := net.Listen("tcp", ":50051")
        // server.Serve(ctx, lis)
}

// createCustomInterceptorConfig demonstrates creating a custom interceptor configuration.
func createCustomInterceptorConfig() *ephemos.InterceptorConfig <span class="cov0" title="0">{
        // Create custom auth config with specific allowed services
        authConfig := interceptors.NewAllowListAuthConfig([]string{
                "spiffe://example.org/echo-client",
                "spiffe://example.org/admin-service",
        })
        authConfig.SkipMethods = []string{
                "/grpc.health.v1.Health/Check",
                "/example.EchoService/Ping", // Custom health check method
        }

        // Create custom logging config for audit requirements
        loggingConfig := interceptors.DefaultLoggingConfig()
        loggingConfig.LogPayloads = true // Enable payload logging for audit
        loggingConfig.IncludeHeaders = []string{
                "authorization",
                "x-request-id",
                "x-forwarded-for",
        }

        // Create custom metrics config
        metricsConfig := interceptors.DefaultMetricsConfig("custom-service")
        metricsConfig.EnablePayloadSize = true
        metricsConfig.EnableActiveRequests = true

        return &amp;ephemos.InterceptorConfig{
                EnableAuth:                true,
                AuthConfig:                authConfig,
                EnableIdentityPropagation: true,
                IdentityPropagationConfig: nil, // Will use defaults
                EnableLogging:             true,
                LoggingConfig:             loggingConfig,
                EnableMetrics:             true,
                MetricsConfig:             metricsConfig,
        }
}</span>

// Example of using interceptors with a client
func clientExample() <span class="cov0" title="0">{
        ctx := context.Background()

        // Create identity client
        client, err := ephemos.NewIdentityClient(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create client", "error", err)
                return
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Connect to service
        conn, err := client.Connect(ctx, "echo-service", "localhost:50051")
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to connect", "error", err)
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create gRPC client
        echoClient := proto.NewEchoServiceClient(conn.GetClientConnection())

        // Make request (interceptors will automatically add identity propagation)
        resp, err := echoClient.Echo(ctx, &amp;proto.EchoRequest{
                Message: "Hello with interceptors!",
        })
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to make request", "error", err)
                return
        }</span>

        <span class="cov0" title="0">slog.Info("Received response", "message", resp.Message, "from", resp.From)</span>
}

// Example of implementing a custom metrics collector
type CustomMetricsCollector struct {
        // Add your metrics backend here (Prometheus, StatsD, etc.)
}

func (c *CustomMetricsCollector) IncRequestsTotal(method, service, code string) <span class="cov0" title="0">{
        // Implement your metrics collection logic
        fmt.Printf("REQUEST: %s %s -&gt; %s\n", service, method, code)
}</span>

func (c *CustomMetricsCollector) ObserveRequestDuration(method, service, code string, duration time.Duration) <span class="cov0" title="0">{
        // Implement your metrics collection logic
        fmt.Printf("DURATION: %s %s -&gt; %s: %v\n", service, method, code, duration)
}</span>

func (c *CustomMetricsCollector) IncActiveRequests(method, service string) <span class="cov0" title="0">{
        fmt.Printf("ACTIVE+: %s %s\n", service, method)
}</span>

func (c *CustomMetricsCollector) DecActiveRequests(method, service string) <span class="cov0" title="0">{
        fmt.Printf("ACTIVE-: %s %s\n", service, method)
}</span>

func (c *CustomMetricsCollector) IncStreamMessagesTotal(method, service, direction string) <span class="cov0" title="0">{
        fmt.Printf("STREAM_MSG: %s %s %s\n", service, method, direction)
}</span>

func (c *CustomMetricsCollector) IncAuthenticationTotal(service, result string) <span class="cov0" title="0">{
        fmt.Printf("AUTH: %s -&gt; %s\n", service, result)
}</span>

func (c *CustomMetricsCollector) ObservePayloadSize(method, service, direction string, size int) <span class="cov0" title="0">{
        fmt.Printf("PAYLOAD_SIZE: %s %s %s -&gt; %d bytes\n", service, method, direction, size)
}</span>

// customMetricsExample demonstrates using a custom metrics collector.
func customMetricsExample() *ephemos.InterceptorConfig <span class="cov0" title="0">{
        config := ephemos.NewDefaultInterceptorConfig()

        // Use custom metrics collector
        config.MetricsConfig.MetricsCollector = &amp;CustomMetricsCollector{}

        return config
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package proto

import (
        "context"
        "fmt"
        "strings"

        "google.golang.org/grpc"
)

// Client provides a generic wrapper for any gRPC service client.
// This demonstrates how developers can create reusable client wrappers
// for their services when using the Ephemos library.
type Client[T any] struct {
        client T
        conn   *grpc.ClientConn
}

// NewClient creates a new Client for the given gRPC connection and client factory.
// The factory function should create a service-specific client from the connection.
//
// Example:
//
//        client, err := NewClient(conn, NewEchoServiceClient)
//        if err != nil {
//                return err
//        }
//        defer client.Close()
func NewClient[T any](conn *grpc.ClientConn, factory func(grpc.ClientConnInterface) T) (*Client[T], error) <span class="cov0" title="0">{
        if conn == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gRPC connection cannot be nil")
        }</span>
        <span class="cov0" title="0">if factory == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("client factory function cannot be nil")
        }</span>

        <span class="cov0" title="0">return &amp;Client[T]{
                client: factory(conn),
                conn:   conn,
        }, nil</span>
}

// Close closes the underlying gRPC connection.
// Should be called when the client is no longer needed.
func (c *Client[T]) Close() error <span class="cov0" title="0">{
        if c.conn != nil </span><span class="cov0" title="0">{
                return c.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Client returns the service-specific gRPC client.
// Use this to access the generated service methods.
func (c *Client[T]) Client() T <span class="cov0" title="0">{
        return c.client
}</span>

// EchoClient is an example wrapper for the EchoServiceClient.
// This shows developers how to create service-specific clients
// that provide additional validation and convenience methods.
type EchoClient struct {
        *Client[EchoServiceClient]
}

// NewEchoClient creates an EchoClient using the generic Client wrapper.
// This demonstrates the recommended pattern for service-specific clients.
//
// Example:
//
//        echoClient, err := proto.NewEchoClient(conn)
//        if err != nil {
//                return err
//        }
//        defer echoClient.Close()
//
//        resp, err := echoClient.Echo(ctx, "Hello, World!")
func NewEchoClient(conn *grpc.ClientConn) (*EchoClient, error) <span class="cov0" title="0">{
        client, err := NewClient(conn, NewEchoServiceClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create echo client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;EchoClient{Client: client}, nil</span>
}

// Echo calls the Echo method on the EchoServiceClient with validation.
// The context supports cancellation and timeouts for the underlying gRPC call.
//
// Parameters:
//   - ctx: Context for cancellation, timeouts, and request metadata
//   - message: The message to echo back from the server
//
// Returns the server's echo response or an error if the call fails.
func (c *EchoClient) Echo(ctx context.Context, message string) (*EchoResponse, error) <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("context cannot be nil")
        }</span>

        <span class="cov0" title="0">if c.Client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("echo client not properly initialized")
        }</span>

        // Get the actual gRPC client via the embedded Client's method
        <span class="cov0" title="0">grpcClient := c.Client.Client()
        if grpcClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("echo service client not properly initialized")
        }</span>

        // Trim whitespace but allow empty messages for echo functionality
        <span class="cov0" title="0">message = strings.TrimSpace(message)

        req := &amp;EchoRequest{Message: message}
        resp, err := grpcClient.Echo(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to call Echo service: %w", err)
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.7
//         protoc        v3.21.12
// source: echo.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// EchoRequest represents an echo request
type EchoRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Message       string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *EchoRequest) Reset() <span class="cov0" title="0">{
        *x = EchoRequest{}
        mi := &amp;file_echo_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EchoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EchoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EchoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_echo_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EchoRequest.ProtoReflect.Descriptor instead.
func (*EchoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_echo_proto_rawDescGZIP(), []int{0}
}</span>

func (x *EchoRequest) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// EchoResponse represents an echo response
type EchoResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Message       string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
        From          string                 `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *EchoResponse) Reset() <span class="cov0" title="0">{
        *x = EchoResponse{}
        mi := &amp;file_echo_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EchoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EchoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EchoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_echo_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EchoResponse.ProtoReflect.Descriptor instead.
func (*EchoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_echo_proto_rawDescGZIP(), []int{1}
}</span>

func (x *EchoResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EchoResponse) GetFrom() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.From
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_echo_proto protoreflect.FileDescriptor

const file_echo_proto_rawDesc = "" +
        "\n" +
        "\n" +
        "echo.proto\x12\fephemos.echo\"'\n" +
        "\vEchoRequest\x12\x18\n" +
        "\amessage\x18\x01 \x01(\tR\amessage\"&lt;\n" +
        "\fEchoResponse\x12\x18\n" +
        "\amessage\x18\x01 \x01(\tR\amessage\x12\x12\n" +
        "\x04from\x18\x02 \x01(\tR\x04from2L\n" +
        "\vEchoService\x12=\n" +
        "\x04Echo\x12\x19.ephemos.echo.EchoRequest\x1a\x1a.ephemos.echo.EchoResponseB+Z)github.com/sufield/ephemos/examples/protob\x06proto3"

var (
        file_echo_proto_rawDescOnce sync.Once
        file_echo_proto_rawDescData []byte
)

func file_echo_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_echo_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_echo_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_echo_proto_rawDesc), len(file_echo_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_echo_proto_rawDescData</span>
}

var file_echo_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_echo_proto_goTypes = []any{
        (*EchoRequest)(nil),  // 0: ephemos.echo.EchoRequest
        (*EchoResponse)(nil), // 1: ephemos.echo.EchoResponse
}
var file_echo_proto_depIdxs = []int32{
        0, // 0: ephemos.echo.EchoService.Echo:input_type -&gt; ephemos.echo.EchoRequest
        1, // 1: ephemos.echo.EchoService.Echo:output_type -&gt; ephemos.echo.EchoResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_echo_proto_init() }</span>
func file_echo_proto_init() <span class="cov0" title="0">{
        if File_echo_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_echo_proto_rawDesc), len(file_echo_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_echo_proto_goTypes,
                DependencyIndexes: file_echo_proto_depIdxs,
                MessageInfos:      file_echo_proto_msgTypes,
        }.Build()
        File_echo_proto = out.File
        file_echo_proto_goTypes = nil
        file_echo_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: echo.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        EchoService_Echo_FullMethodName = "/ephemos.echo.EchoService/Echo"
)

// EchoServiceClient is the client API for EchoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// EchoService provides a simple echo functionality for testing
// This is an example service definition that developers can use as a template
// when building their own services with the Ephemos library.
type EchoServiceClient interface {
        Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
}

type echoServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewEchoServiceClient(cc grpc.ClientConnInterface) EchoServiceClient <span class="cov0" title="0">{
        return &amp;echoServiceClient{cc}
}</span>

func (c *echoServiceClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EchoResponse)
        err := c.cc.Invoke(ctx, EchoService_Echo_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// EchoServiceServer is the server API for EchoService service.
// All implementations must embed UnimplementedEchoServiceServer
// for forward compatibility.
//
// EchoService provides a simple echo functionality for testing
// This is an example service definition that developers can use as a template
// when building their own services with the Ephemos library.
type EchoServiceServer interface {
        Echo(context.Context, *EchoRequest) (*EchoResponse, error)
        mustEmbedUnimplementedEchoServiceServer()
}

// UnimplementedEchoServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEchoServiceServer struct{}

func (UnimplementedEchoServiceServer) Echo(context.Context, *EchoRequest) (*EchoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}</span>
func (UnimplementedEchoServiceServer) mustEmbedUnimplementedEchoServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedEchoServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeEchoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EchoServiceServer will
// result in compilation errors.
type UnsafeEchoServiceServer interface {
        mustEmbedUnimplementedEchoServiceServer()
}

func RegisterEchoServiceServer(s grpc.ServiceRegistrar, srv EchoServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedEchoServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;EchoService_ServiceDesc, srv)</span>
}

func _EchoService_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(EchoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EchoServiceServer).Echo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EchoService_Echo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EchoServiceServer).Echo(ctx, req.(*EchoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// EchoService_ServiceDesc is the grpc.ServiceDesc for EchoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EchoService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "ephemos.echo.EchoService",
        HandlerType: (*EchoServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Echo",
                        Handler:    _EchoService_Echo_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "echo.proto",
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package proto

import (
        "google.golang.org/grpc"
)

// EchoServiceRegistrar is an example registrar for the Echo service.
// This demonstrates how developers should implement service registration
// when using the Ephemos library for identity-based authentication.
//
// Developers should create similar registrars for their own services
// by implementing the ServiceRegistrar interface.
type EchoServiceRegistrar struct {
        server EchoServiceServer
}

// NewEchoServiceRegistrar creates a registrar for the Echo service.
// The server parameter should implement the EchoServiceServer interface
// with the actual business logic for the service.
//
// Example:
//
//        server := &amp;MyEchoServer{} // implements EchoServiceServer
//        registrar := proto.NewEchoServiceRegistrar(server)
//        err := ephemosServer.RegisterService(ctx, registrar)
func NewEchoServiceRegistrar(server EchoServiceServer) *EchoServiceRegistrar <span class="cov0" title="0">{
        return &amp;EchoServiceRegistrar{
                server: server,
        }
}</span>

// Register registers the Echo service with the provided gRPC server.
// This method is called by the Ephemos framework when setting up
// the identity-aware gRPC server.
//
// This implements the ServiceRegistrar interface required by Ephemos.
func (r *EchoServiceRegistrar) Register(grpcServer *grpc.Server) <span class="cov0" title="0">{
        RegisterEchoServiceServer(grpcServer, r.server)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package interceptors provides built-in gRPC interceptors for authentication and identity propagation.
package interceptors

import (
        "context"
        "crypto/x509"
        "fmt"
        "log/slog"
        "strings"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/peer"
        "google.golang.org/grpc/status"
)

// IdentityContextKey is the context key for storing identity information.
type IdentityContextKey struct{}

// AuthConfig contains configuration for authentication interceptors.
type AuthConfig struct {
        // RequireAuthentication determines if authentication is mandatory
        RequireAuthentication bool

        // AllowedServices contains SPIFFE IDs that are allowed to call this service
        AllowedServices []string

        // DenyAllowed services (blacklist mode) - if true, AllowedServices acts as a blacklist
        DenyMode bool

        // RequiredClaims are custom claims that must be present in the identity
        RequiredClaims map[string]string

        // SkipMethods are method names that bypass authentication (format: /service.Service/Method)
        SkipMethods []string

        // Logger for authentication events
        Logger *slog.Logger
}

// AuthenticatedIdentity represents an authenticated client identity.
type AuthenticatedIdentity struct {
        // SPIFFE ID of the authenticated client
        SPIFFEID string

        // X.509 certificate used for authentication
        Certificate *x509.Certificate

        // Trust domain extracted from SPIFFE ID
        TrustDomain string

        // Service name extracted from SPIFFE ID
        ServiceName string

        // Workload path extracted from SPIFFE ID
        WorkloadPath string

        // Additional claims from the certificate
        Claims map[string]string

        // Authentication timestamp
        AuthTime int64
}

// AuthInterceptor provides authentication and authorization for gRPC services.
type AuthInterceptor struct {
        config *AuthConfig
        logger *slog.Logger
}

// NewAuthInterceptor creates a new authentication interceptor with the given configuration.
func NewAuthInterceptor(config *AuthConfig) *AuthInterceptor <span class="cov10" title="31">{
        logger := config.Logger
        if logger == nil </span><span class="cov7" title="10">{
                logger = slog.Default()
        }</span>

        <span class="cov10" title="31">return &amp;AuthInterceptor{
                config: config,
                logger: logger,
        }</span>
}

// UnaryServerInterceptor returns a gRPC unary server interceptor for authentication.
func (a *AuthInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov5" title="6">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov5" title="6">{
                // Check if method should skip authentication
                if a.shouldSkipMethod(info.FullMethod) </span><span class="cov1" title="1">{
                        a.logger.Debug("Skipping authentication for method", "method", info.FullMethod)
                        return handler(ctx, req)
                }</span>

                // Perform authentication
                <span class="cov5" title="5">authenticatedCtx, err := a.authenticateRequest(ctx, info.FullMethod)
                if err != nil </span><span class="cov3" title="3">{
                        a.logger.Warn("Authentication failed",
                                "method", info.FullMethod,
                                "error", err)
                        return nil, err
                }</span>

                // Call the handler with authenticated context
                <span class="cov2" title="2">return handler(authenticatedCtx, req)</span>
        }
}

// StreamServerInterceptor returns a gRPC stream server interceptor for authentication.
func (a *AuthInterceptor) StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov2" title="2">{
        return func(
                srv interface{},
                ss grpc.ServerStream,
                info *grpc.StreamServerInfo,
                handler grpc.StreamHandler,
        ) error </span><span class="cov0" title="0">{
                // Check if method should skip authentication
                if a.shouldSkipMethod(info.FullMethod) </span><span class="cov0" title="0">{
                        a.logger.Debug("Skipping authentication for stream method", "method", info.FullMethod)
                        return handler(srv, ss)
                }</span>

                // Perform authentication
                <span class="cov0" title="0">authenticatedCtx, err := a.authenticateRequest(ss.Context(), info.FullMethod)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Warn("Stream authentication failed",
                                "method", info.FullMethod,
                                "error", err)
                        return err
                }</span>

                // Wrap the server stream with authenticated context
                <span class="cov0" title="0">wrappedStream := &amp;authenticatedServerStream{
                        ServerStream: ss,
                        ctx:          authenticatedCtx,
                }

                return handler(srv, wrappedStream)</span>
        }
}

// authenticatedServerStream wraps a grpc.ServerStream with an authenticated context.
type authenticatedServerStream struct {
        grpc.ServerStream
        ctx context.Context //nolint:containedctx // Required for gRPC ServerStream interface
}

// Context returns the authenticated context.
func (s *authenticatedServerStream) Context() context.Context <span class="cov0" title="0">{
        return s.ctx
}</span>

// authenticateRequest performs the actual authentication logic.
func (a *AuthInterceptor) authenticateRequest(ctx context.Context, method string) (context.Context, error) <span class="cov5" title="5">{
        // Extract peer information
        peer, ok := peer.FromContext(ctx)
        if !ok </span><span class="cov2" title="2">{
                if a.config.RequireAuthentication </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("no peer information available: %w", status.Error(codes.Unauthenticated, "no peer information available"))
                }</span>
                <span class="cov1" title="1">return ctx, nil</span>
        }

        // Extract TLS certificate information
        <span class="cov3" title="3">tlsInfo, ok := peer.AuthInfo.(credentials.TLSInfo)
        if !ok </span><span class="cov1" title="1">{
                if a.config.RequireAuthentication </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("TLS authentication required: %w", status.Error(codes.Unauthenticated, "TLS authentication required"))
                }</span>
                <span class="cov0" title="0">return ctx, nil</span>
        }

        // Verify we have peer certificates
        <span class="cov2" title="2">if len(tlsInfo.State.PeerCertificates) == 0 </span><span class="cov0" title="0">{
                if a.config.RequireAuthentication </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no peer certificates provided: %w", status.Error(codes.Unauthenticated, "no peer certificates provided"))
                }</span>
                <span class="cov0" title="0">return ctx, nil</span>
        }

        // Extract identity from certificate
        <span class="cov2" title="2">clientCert := tlsInfo.State.PeerCertificates[0]
        identity, err := a.extractIdentityFromCertificate(clientCert)
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Failed to extract identity from certificate", "error", err)
                return nil, fmt.Errorf("invalid certificate identity: %w", status.Error(codes.Unauthenticated, "invalid certificate identity"))
        }</span>

        // Perform authorization checks
        <span class="cov2" title="2">if err := a.authorizeIdentity(identity, method); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Add identity to context
        <span class="cov1" title="1">authenticatedCtx := context.WithValue(ctx, IdentityContextKey{}, identity)

        a.logger.Info("Client authenticated successfully",
                "spiffe_id", identity.SPIFFEID,
                "service", identity.ServiceName,
                "method", method)

        return authenticatedCtx, nil</span>
}

// extractIdentityFromCertificate extracts SPIFFE identity from an X.509 certificate.
func (a *AuthInterceptor) extractIdentityFromCertificate(cert *x509.Certificate) (*AuthenticatedIdentity, error) <span class="cov2" title="2">{
        // Look for SPIFFE ID in Subject Alternative Names (URI SAN)
        var spiffeID string
        for _, uri := range cert.URIs </span><span class="cov2" title="2">{
                if uri.Scheme == "spiffe" </span><span class="cov2" title="2">{
                        spiffeID = uri.String()
                        break</span>
                }
        }

        <span class="cov2" title="2">if spiffeID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no SPIFFE ID found in certificate")
        }</span>

        // Parse SPIFFE ID components
        <span class="cov2" title="2">identity, err := a.parseSpiffeID(spiffeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse SPIFFE ID %s: %w", spiffeID, err)
        }</span>

        // Set certificate and authentication time
        <span class="cov2" title="2">identity.Certificate = cert
        identity.AuthTime = cert.NotBefore.Unix()

        return identity, nil</span>
}

// parseSpiffeID parses a SPIFFE ID into its components.
func (a *AuthInterceptor) parseSpiffeID(spiffeID string) (*AuthenticatedIdentity, error) <span class="cov7" title="13">{
        // SPIFFE ID format: spiffe://trust-domain/path/to/workload
        if !strings.HasPrefix(spiffeID, "spiffe://") </span><span class="cov5" title="5">{
                return nil, fmt.Errorf("invalid SPIFFE ID format: %s", spiffeID)
        }</span>

        // Remove spiffe:// prefix
        <span class="cov6" title="8">idPath := strings.TrimPrefix(spiffeID, "spiffe://")

        // Split trust domain and path
        parts := strings.SplitN(idPath, "/", 2)
        if len(parts) &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid SPIFFE ID structure: %s", spiffeID)
        }</span>

        <span class="cov6" title="8">trustDomain := parts[0]
        if trustDomain == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("empty trust domain in SPIFFE ID: %s", spiffeID)
        }</span>

        <span class="cov6" title="7">var workloadPath, serviceName string

        if len(parts) &gt; 1 </span><span class="cov5" title="5">{
                workloadPath = "/" + parts[1]

                // Extract service name from path (last component)
                pathParts := strings.Split(parts[1], "/")
                if len(pathParts) &gt; 0 </span><span class="cov5" title="5">{
                        serviceName = pathParts[len(pathParts)-1]
                }</span>
        }

        <span class="cov6" title="7">return &amp;AuthenticatedIdentity{
                SPIFFEID:     spiffeID,
                TrustDomain:  trustDomain,
                ServiceName:  serviceName,
                WorkloadPath: workloadPath,
                Claims:       make(map[string]string),
        }, nil</span>
}

// authorizeIdentity performs authorization checks on the authenticated identity.
func (a *AuthInterceptor) authorizeIdentity(identity *AuthenticatedIdentity, _ string) error <span class="cov7" title="13">{
        // Check allowed/denied services with early returns (guard clauses)
        if len(a.config.AllowedServices) == 0 </span><span class="cov5" title="5">{
                // No service restrictions - proceed to claims check
                return a.validateRequiredClaims(identity)
        }</span>

        <span class="cov6" title="8">isInList := a.isServiceInList(identity.SPIFFEID, a.config.AllowedServices)

        // Blacklist mode - deny if in list
        if a.config.DenyMode &amp;&amp; isInList </span><span class="cov3" title="3">{
                return status.Errorf(codes.PermissionDenied,
                        "service %s is denied access", identity.SPIFFEID)
        }</span>

        // Whitelist mode - allow only if in list
        <span class="cov5" title="5">if !a.config.DenyMode &amp;&amp; !isInList </span><span class="cov1" title="1">{
                return status.Errorf(codes.PermissionDenied,
                        "service %s is not authorized", identity.SPIFFEID)
        }</span>

        // Service authorization passed - check claims
        <span class="cov4" title="4">return a.validateRequiredClaims(identity)</span>
}

// Helper function to validate required claims (reduces complexity).
func (a *AuthInterceptor) validateRequiredClaims(identity *AuthenticatedIdentity) error <span class="cov6" title="9">{
        for claimKey, requiredValue := range a.config.RequiredClaims </span><span class="cov5" title="5">{
                actualValue, exists := identity.Claims[claimKey]
                if !hasRequiredClaimValue(exists, actualValue, requiredValue) </span><span class="cov2" title="2">{
                        return status.Errorf(codes.PermissionDenied,
                                "missing or invalid claim: %s", claimKey)
                }</span>
        }
        <span class="cov6" title="7">return nil</span>
}

// hasRequiredClaimValue checks if a claim exists and matches the required value.
func hasRequiredClaimValue(exists bool, actualValue, requiredValue string) bool <span class="cov5" title="5">{
        return exists &amp;&amp; actualValue == requiredValue
}</span>

// isServiceInList checks if a SPIFFE ID matches any pattern in the service list.
func (a *AuthInterceptor) isServiceInList(spiffeID string, services []string) bool <span class="cov6" title="8">{
        for _, service := range services </span><span class="cov6" title="8">{
                if a.matchesPattern(spiffeID, service) </span><span class="cov5" title="5">{
                        return true
                }</span>
        }
        <span class="cov3" title="3">return false</span>
}

// matchesPattern checks if a SPIFFE ID matches a pattern (supports wildcards).
func (a *AuthInterceptor) matchesPattern(spiffeID, pattern string) bool <span class="cov9" title="26">{
        // Exact match
        if spiffeID == pattern </span><span class="cov5" title="6">{
                return true
        }</span>

        // Wildcard support
        <span class="cov8" title="20">if strings.Contains(pattern, "*") </span><span class="cov7" title="13">{
                // Simple prefix/suffix wildcard matching
                if strings.HasPrefix(pattern, "*") </span><span class="cov5" title="5">{
                        suffix := strings.TrimPrefix(pattern, "*")
                        return strings.HasSuffix(spiffeID, suffix)
                }</span>
                <span class="cov6" title="8">if strings.HasSuffix(pattern, "*") </span><span class="cov6" title="8">{
                        prefix := strings.TrimSuffix(pattern, "*")
                        return strings.HasPrefix(spiffeID, prefix)
                }</span>
        }

        <span class="cov6" title="7">return false</span>
}

// shouldSkipMethod checks if a method should skip authentication.
func (a *AuthInterceptor) shouldSkipMethod(method string) bool <span class="cov5" title="6">{
        for _, skipMethod := range a.config.SkipMethods </span><span class="cov1" title="1">{
                if method == skipMethod </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov5" title="5">return false</span>
}

// GetIdentityFromContext extracts the authenticated identity from a gRPC context.
func GetIdentityFromContext(ctx context.Context) (*AuthenticatedIdentity, bool) <span class="cov8" title="19">{
        identity, ok := ctx.Value(IdentityContextKey{}).(*AuthenticatedIdentity)
        return identity, ok
}</span>

// RequireIdentity extracts the authenticated identity from context and returns an error if not found.
func RequireIdentity(ctx context.Context) (*AuthenticatedIdentity, error) <span class="cov4" title="4">{
        identity, ok := GetIdentityFromContext(ctx)
        if !ok </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("no authenticated identity found: %w", status.Error(codes.Unauthenticated, "no authenticated identity found"))
        }</span>
        <span class="cov2" title="2">return identity, nil</span>
}

// DefaultAuthConfig returns a default authentication configuration.
func DefaultAuthConfig() *AuthConfig <span class="cov8" title="18">{
        return &amp;AuthConfig{
                RequireAuthentication: true,
                AllowedServices:       []string{}, // Allow all by default
                DenyMode:              false,
                RequiredClaims:        make(map[string]string),
                SkipMethods:           []string{},
                Logger:                slog.Default(),
        }
}</span>

// NewAllowListAuthConfig creates an auth config that only allows specific services.
func NewAllowListAuthConfig(allowedServices []string) *AuthConfig <span class="cov1" title="1">{
        config := DefaultAuthConfig()
        config.AllowedServices = allowedServices
        config.DenyMode = false
        return config
}</span>

// NewDenyListAuthConfig creates an auth config that denies specific services.
func NewDenyListAuthConfig(deniedServices []string) *AuthConfig <span class="cov1" title="1">{
        config := DefaultAuthConfig()
        config.AllowedServices = deniedServices
        config.DenyMode = true
        return config
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package interceptors

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"

        "github.com/sufield/ephemos/internal/core/ports"
)

// Default configuration constants.
const defaultMaxCallChainDepth = 10

const (
        // MetadataKeyOriginalCaller is the metadata key for original caller identity.
        MetadataKeyOriginalCaller = "x-ephemos-original-caller"
        // MetadataKeyCallChain is the metadata key for the call chain.
        MetadataKeyCallChain = "x-ephemos-call-chain"
        // MetadataKeyTrustDomain is the metadata key for trust domain.
        MetadataKeyTrustDomain = "x-ephemos-trust-domain"
        // MetadataKeyServiceName is the metadata key for service name.
        MetadataKeyServiceName = "x-ephemos-service-name"
        // MetadataKeyRequestID is the metadata key for request ID.
        MetadataKeyRequestID = "x-ephemos-request-id"
        // MetadataKeyTimestamp is the metadata key for timestamp.
        MetadataKeyTimestamp = "x-ephemos-timestamp"
)

// IdentityPropagationConfig configures identity propagation behavior.
type IdentityPropagationConfig struct {
        // IdentityProvider to get current service identity
        IdentityProvider ports.IdentityProvider

        // PropagateOriginalCaller forwards the original caller identity
        PropagateOriginalCaller bool

        // PropagateCallChain builds and forwards the call chain
        PropagateCallChain bool

        // MaxCallChainDepth limits the depth of call chain to prevent loops
        MaxCallChainDepth int

        // CustomHeaders are additional headers to propagate
        CustomHeaders []string

        // Logger for propagation events
        Logger *slog.Logger
}

// IdentityPropagationInterceptor handles identity propagation for outgoing gRPC calls.
type IdentityPropagationInterceptor struct {
        config *IdentityPropagationConfig
        logger *slog.Logger
}

// NewIdentityPropagationInterceptor creates a new identity propagation interceptor.
func NewIdentityPropagationInterceptor(config *IdentityPropagationConfig) *IdentityPropagationInterceptor <span class="cov10" title="19">{
        logger := config.Logger
        if logger == nil </span><span class="cov6" title="6">{
                logger = slog.Default()
        }</span>

        // Set default max call chain depth
        <span class="cov10" title="19">if config.MaxCallChainDepth == 0 </span><span class="cov6" title="7">{
                config.MaxCallChainDepth = 10
        }</span>

        <span class="cov10" title="19">return &amp;IdentityPropagationInterceptor{
                config: config,
                logger: logger,
        }</span>
}

// UnaryClientInterceptor returns a gRPC unary client interceptor for identity propagation.
func (i *IdentityPropagationInterceptor) UnaryClientInterceptor() grpc.UnaryClientInterceptor <span class="cov3" title="2">{
        return func(
                ctx context.Context,
                method string,
                req, reply interface{},
                cc *grpc.ClientConn,
                invoker grpc.UnaryInvoker,
                opts ...grpc.CallOption,
        ) error </span><span class="cov3" title="2">{
                // Create context with propagated identity metadata
                propagatedCtx, err := i.propagateIdentity(ctx, method)
                if err != nil </span><span class="cov1" title="1">{
                        i.logger.Error("Failed to propagate identity",
                                "method", method,
                                "error", err)
                        return err
                }</span>

                // Make the call with propagated context
                <span class="cov1" title="1">return invoker(propagatedCtx, method, req, reply, cc, opts...)</span>
        }
}

// StreamClientInterceptor returns a gRPC stream client interceptor for identity propagation.
func (i *IdentityPropagationInterceptor) StreamClientInterceptor() grpc.StreamClientInterceptor <span class="cov1" title="1">{
        return func(
                ctx context.Context,
                desc *grpc.StreamDesc,
                cc *grpc.ClientConn,
                method string,
                streamer grpc.Streamer,
                opts ...grpc.CallOption,
        ) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                // Create context with propagated identity metadata
                propagatedCtx, err := i.propagateIdentity(ctx, method)
                if err != nil </span><span class="cov0" title="0">{
                        i.logger.Error("Failed to propagate identity for stream",
                                "method", method,
                                "error", err)
                        return nil, err
                }</span>

                // Create the stream with propagated context
                <span class="cov0" title="0">return streamer(propagatedCtx, desc, cc, method, opts...)</span>
        }
}

// propagateIdentity adds identity metadata to the outgoing context.
func (i *IdentityPropagationInterceptor) propagateIdentity(ctx context.Context, method string) (context.Context, error) <span class="cov7" title="9">{
        // Get current service identity
        identity, err := i.config.IdentityProvider.GetServiceIdentity()
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get service identity: %w", err)
        }</span>

        // Create metadata for identity propagation
        <span class="cov7" title="8">md := metadata.MD{}

        // Add current service identity
        md.Set(MetadataKeyServiceName, identity.Name)
        md.Set(MetadataKeyTrustDomain, identity.Domain)
        md.Set(MetadataKeyTimestamp, fmt.Sprintf("%d", time.Now().Unix()))

        // Generate or extract request ID
        requestID := i.getOrGenerateRequestID(ctx)
        md.Set(MetadataKeyRequestID, requestID)

        // Handle original caller propagation
        if i.config.PropagateOriginalCaller </span><span class="cov4" title="3">{
                originalCaller := i.getOriginalCaller(ctx, identity.URI)
                md.Set(MetadataKeyOriginalCaller, originalCaller)
        }</span>

        // Handle call chain propagation
        <span class="cov7" title="8">if i.config.PropagateCallChain </span><span class="cov5" title="5">{
                callChain, err := i.buildCallChain(ctx, identity.URI)
                if err != nil </span><span class="cov3" title="2">{
                        return nil, fmt.Errorf("failed to build call chain: %w", err)
                }</span>
                <span class="cov4" title="3">if callChain != "" </span><span class="cov4" title="3">{
                        md.Set(MetadataKeyCallChain, callChain)
                }</span>
        }

        // Propagate custom headers
        <span class="cov6" title="6">i.propagateCustomHeaders(ctx, md)

        // Merge with existing metadata
        existingMD, ok := metadata.FromOutgoingContext(ctx)
        if ok </span><span class="cov0" title="0">{
                md = metadata.Join(existingMD, md)
        }</span>

        <span class="cov6" title="6">i.logger.Debug("Identity propagated",
                "method", method,
                "service", identity.Name,
                "request_id", requestID)

        return metadata.NewOutgoingContext(ctx, md), nil</span>
}

// getOriginalCaller determines the original caller in the chain.
func (i *IdentityPropagationInterceptor) getOriginalCaller(ctx context.Context, currentIdentity string) string <span class="cov4" title="3">{
        // Check if we already have an original caller in incoming metadata
        if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov1" title="1">{
                if originalCaller := md.Get(MetadataKeyOriginalCaller); len(originalCaller) &gt; 0 </span><span class="cov1" title="1">{
                        return originalCaller[0] // Preserve the original caller
                }</span>
        }

        // If no original caller, we are the original caller
        <span class="cov3" title="2">return currentIdentity</span>
}

// buildCallChain creates or extends the call chain.
func (i *IdentityPropagationInterceptor) buildCallChain(ctx context.Context, currentIdentity string) (string, error) <span class="cov8" title="12">{
        var callChain []string

        // Extract existing call chain using guard clauses
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov5" title="4">{
                // No incoming metadata - start new chain
                return currentIdentity, nil
        }</span>

        <span class="cov7" title="8">existingChain := md.Get(MetadataKeyCallChain)
        if len(existingChain) == 0 </span><span class="cov0" title="0">{
                // No existing chain - start new chain
                return currentIdentity, nil
        }</span>

        // Parse existing chain
        <span class="cov7" title="8">callChain = strings.Split(existingChain[0], " -&gt; ")

        // Validate chain depth limit
        if len(callChain) &gt;= i.config.MaxCallChainDepth </span><span class="cov4" title="3">{
                return "", fmt.Errorf("call chain depth limit exceeded (%d)", i.config.MaxCallChainDepth)
        }</span>

        // Check for circular calls
        <span class="cov5" title="5">if err := i.validateNoCycle(callChain, currentIdentity); err != nil </span><span class="cov4" title="3">{
                return "", err
        }</span>

        // Add current service to the chain
        <span class="cov3" title="2">callChain = append(callChain, currentIdentity)

        return strings.Join(callChain, " -&gt; "), nil</span>
}

// Helper function to validate no circular calls (reduces complexity).
func (i *IdentityPropagationInterceptor) validateNoCycle(callChain []string, currentIdentity string) error <span class="cov5" title="5">{
        for _, service := range callChain </span><span class="cov7" title="8">{
                if service == currentIdentity </span><span class="cov4" title="3">{
                        return fmt.Errorf("circular call detected: %s already in chain", currentIdentity)
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// propagateCustomHeaders copies specified custom headers from incoming to outgoing metadata.
func (i *IdentityPropagationInterceptor) propagateCustomHeaders(ctx context.Context, outgoingMD metadata.MD) <span class="cov6" title="6">{
        if len(i.config.CustomHeaders) == 0 </span><span class="cov5" title="5">{
                return
        }</span>

        <span class="cov1" title="1">incomingMD, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return // No incoming metadata to propagate
        }</span>

        <span class="cov1" title="1">for _, header := range i.config.CustomHeaders </span><span class="cov3" title="2">{
                if values := incomingMD.Get(header); len(values) &gt; 0 </span><span class="cov3" title="2">{
                        outgoingMD.Set(header, values...)
                }</span>
        }
}

// getOrGenerateRequestID gets an existing request ID or generates a new one.
func (i *IdentityPropagationInterceptor) getOrGenerateRequestID(ctx context.Context) string <span class="cov9" title="16">{
        // Check for existing request ID in incoming metadata
        if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov7" title="8">{
                if requestID := md.Get(MetadataKeyRequestID); len(requestID) &gt; 0 </span><span class="cov4" title="3">{
                        return requestID[0]
                }</span>
        }

        // Check for request ID in context value (set by application)
        <span class="cov8" title="13">if requestID, ok := ctx.Value("request-id").(string); ok </span><span class="cov3" title="2">{
                return requestID
        }</span>

        // Generate new request ID
        <span class="cov8" title="11">return generateRequestID()</span>
}

// generateRequestID creates a new unique request ID.
func generateRequestID() string <span class="cov8" title="13">{
        return fmt.Sprintf("req-%d", time.Now().UnixNano())
}</span>

// IdentityPropagationServerInterceptor provides server-side identity extraction from propagated metadata.
type IdentityPropagationServerInterceptor struct {
        logger *slog.Logger
}

// NewIdentityPropagationServerInterceptor creates a server interceptor for identity extraction.
func NewIdentityPropagationServerInterceptor(logger *slog.Logger) *IdentityPropagationServerInterceptor <span class="cov5" title="5">{
        if logger == nil </span><span class="cov1" title="1">{
                logger = slog.Default()
        }</span>

        <span class="cov5" title="5">return &amp;IdentityPropagationServerInterceptor{
                logger: logger,
        }</span>
}

// UnaryServerInterceptor returns a gRPC unary server interceptor for identity extraction.
func (i *IdentityPropagationServerInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov4" title="3">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov4" title="3">{
                // Extract and add identity information to context
                enrichedCtx := i.extractIdentityMetadata(ctx, info.FullMethod)

                return handler(enrichedCtx, req)
        }</span>
}

// StreamServerInterceptor returns a gRPC stream server interceptor for identity extraction.
func (i *IdentityPropagationServerInterceptor) StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov0" title="0">{
        return func(
                srv interface{},
                ss grpc.ServerStream,
                info *grpc.StreamServerInfo,
                handler grpc.StreamHandler,
        ) error </span><span class="cov0" title="0">{
                // Extract and add identity information to context
                enrichedCtx := i.extractIdentityMetadata(ss.Context(), info.FullMethod)

                // Wrap stream with enriched context
                wrappedStream := &amp;enrichedServerStream{
                        ServerStream: ss,
                        ctx:          enrichedCtx,
                }

                return handler(srv, wrappedStream)
        }</span>
}

// enrichedServerStream wraps a grpc.ServerStream with an enriched context.
type enrichedServerStream struct {
        grpc.ServerStream
        ctx context.Context //nolint:containedctx // Required for gRPC ServerStream interface
}

// Context returns the enriched context.
func (s *enrichedServerStream) Context() context.Context <span class="cov0" title="0">{
        return s.ctx
}</span>

// extractIdentityMetadata extracts identity metadata from incoming context and enriches it.
func (i *IdentityPropagationServerInterceptor) extractIdentityMetadata(ctx context.Context, method string) context.Context <span class="cov4" title="3">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return ctx
        }</span>

        <span class="cov4" title="3">enrichedCtx := ctx

        // Use predefined context keys

        // Extract propagated identity information
        if originalCaller := md.Get(MetadataKeyOriginalCaller); len(originalCaller) &gt; 0 </span><span class="cov1" title="1">{
                enrichedCtx = context.WithValue(enrichedCtx, originalCallerKey, originalCaller[0])
        }</span>

        <span class="cov4" title="3">if callChain := md.Get(MetadataKeyCallChain); len(callChain) &gt; 0 </span><span class="cov1" title="1">{
                enrichedCtx = context.WithValue(enrichedCtx, callChainKey, callChain[0])
        }</span>

        <span class="cov4" title="3">if trustDomain := md.Get(MetadataKeyTrustDomain); len(trustDomain) &gt; 0 </span><span class="cov1" title="1">{
                enrichedCtx = context.WithValue(enrichedCtx, callerTrustDomainKey, trustDomain[0])
        }</span>

        <span class="cov4" title="3">if serviceName := md.Get(MetadataKeyServiceName); len(serviceName) &gt; 0 </span><span class="cov3" title="2">{
                enrichedCtx = context.WithValue(enrichedCtx, callerServiceKey, serviceName[0])
        }</span>

        <span class="cov4" title="3">if requestID := md.Get(MetadataKeyRequestID); len(requestID) &gt; 0 </span><span class="cov3" title="2">{
                enrichedCtx = context.WithValue(enrichedCtx, requestIDKey, requestID[0])

                i.logger.Debug("Identity metadata extracted",
                        "method", method,
                        "request_id", requestID[0],
                        "caller_service", getValueFromContext(enrichedCtx, "caller-service"),
                        "call_chain", getValueFromContext(enrichedCtx, "call-chain"))
        }</span>

        <span class="cov4" title="3">return enrichedCtx</span>
}

// Helper function to safely get string values from context.
func getValueFromContext(ctx context.Context, key string) string <span class="cov5" title="4">{
        if value, ok := ctx.Value(key).(string); ok </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov5" title="4">return ""</span>
}

// Identity propagation helper functions

// Context key type for safe context values.
type contextKey string

// Context keys.
const (
        originalCallerKey    contextKey = "original-caller"
        callChainKey         contextKey = "call-chain"
        callerTrustDomainKey contextKey = "caller-trust-domain"
        callerServiceKey     contextKey = "caller-service"
        requestIDKey         contextKey = "request-id"
)

// GetOriginalCaller extracts the original caller from the context.
func GetOriginalCaller(ctx context.Context) (string, bool) <span class="cov8" title="10">{
        originalCaller, ok := ctx.Value(originalCallerKey).(string)
        return originalCaller, ok
}</span>

// GetCallChain extracts the call chain from the context.
func GetCallChain(ctx context.Context) (string, bool) <span class="cov8" title="10">{
        callChain, ok := ctx.Value(callChainKey).(string)
        return callChain, ok
}</span>

// GetCallerService extracts the immediate caller service from the context.
func GetCallerService(ctx context.Context) (string, bool) <span class="cov5" title="4">{
        callerService, ok := ctx.Value(callerServiceKey).(string)
        return callerService, ok
}</span>

// GetCallerTrustDomain extracts the caller's trust domain from the context.
func GetCallerTrustDomain(ctx context.Context) (string, bool) <span class="cov4" title="3">{
        trustDomain, ok := ctx.Value(callerTrustDomainKey).(string)
        return trustDomain, ok
}</span>

// GetRequestID extracts the request ID from the context.
func GetRequestID(ctx context.Context) (string, bool) <span class="cov8" title="11">{
        requestID, ok := ctx.Value(requestIDKey).(string)
        return requestID, ok
}</span>

// DefaultIdentityPropagationConfig returns a default identity propagation configuration.
func DefaultIdentityPropagationConfig(identityProvider ports.IdentityProvider) *IdentityPropagationConfig <span class="cov5" title="5">{
        return &amp;IdentityPropagationConfig{
                IdentityProvider:        identityProvider,
                PropagateOriginalCaller: true,
                PropagateCallChain:      true,
                MaxCallChainDepth:       defaultMaxCallChainDepth,
                CustomHeaders:           []string{},
                Logger:                  slog.Default(),
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package interceptors

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/status"

        "github.com/sufield/ephemos/internal/adapters/logging"
)

const (
        // Default thresholds for logging configuration.
        defaultSlowThreshold = 500 * time.Millisecond
        debugSlowThreshold   = 100 * time.Millisecond
)

// LoggingConfig configures audit logging behavior.
type LoggingConfig struct {
        // Logger instance (will use secure logger with redaction)
        Logger *slog.Logger

        // LogRequests enables request logging
        LogRequests bool

        // LogResponses enables response logging (be careful with sensitive data)
        LogResponses bool

        // LogPayloads includes request/response payloads in logs
        LogPayloads bool

        // SlowRequestThreshold logs requests that take longer than this duration
        SlowRequestThreshold time.Duration

        // ExcludeMethods are methods that should not be logged (e.g., health checks)
        ExcludeMethods []string

        // IncludeHeaders are specific headers to include in logs
        IncludeHeaders []string
}

// LoggingInterceptor provides structured audit logging for gRPC services.
type LoggingInterceptor struct {
        config *LoggingConfig
        logger *slog.Logger
}

// NewLoggingInterceptor creates a new logging interceptor with secure redaction.
func NewLoggingInterceptor(config *LoggingConfig) *LoggingInterceptor <span class="cov10" title="16">{
        logger := config.Logger
        if logger == nil </span><span class="cov8" title="9">{
                // Use secure logger with automatic redaction
                secureLogger := logging.NewSecureLogger(slog.Default().Handler())
                logger = secureLogger
        }</span>

        // Set default slow request threshold
        <span class="cov10" title="16">if config.SlowRequestThreshold == 0 </span><span class="cov8" title="9">{
                const defaultSlowThreshold = 500 * time.Millisecond
                config.SlowRequestThreshold = defaultSlowThreshold
        }</span>

        <span class="cov10" title="16">return &amp;LoggingInterceptor{
                config: config,
                logger: logger,
        }</span>
}

// UnaryServerInterceptor returns a gRPC unary server interceptor for logging.
func (l *LoggingInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov6" title="6">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov6" title="6">{
                // Check if method should be excluded from logging
                if l.shouldExcludeMethod(info.FullMethod) </span><span class="cov1" title="1">{
                        return handler(ctx, req)
                }</span>

                <span class="cov6" title="5">start := time.Now()

                // Extract identity and request information
                logEntry := l.createBaseLogEntry(ctx, info.FullMethod, "unary")

                // Log request if enabled
                if l.config.LogRequests </span><span class="cov1" title="1">{
                        requestEntry := logEntry.With("event", "request_received")
                        if l.config.LogPayloads </span><span class="cov1" title="1">{
                                requestEntry = requestEntry.With("request_payload", req)
                        }</span>
                        <span class="cov1" title="1">requestEntry.Info("gRPC request received")</span>
                }

                // Call the handler
                <span class="cov6" title="5">resp, err := handler(ctx, req)

                duration := time.Since(start)

                // Determine log level based on error and duration
                logLevel := slog.LevelInfo
                if err != nil </span><span class="cov1" title="1">{
                        logLevel = slog.LevelError
                }</span> else<span class="cov5" title="4"> if duration &gt; l.config.SlowRequestThreshold </span><span class="cov1" title="1">{
                        logLevel = slog.LevelWarn
                }</span>

                // Create response log entry
                <span class="cov6" title="5">responseEntry := logEntry.With(
                        "event", "request_completed",
                        "duration_ms", duration.Milliseconds(),
                        "success", err == nil,
                )

                // Add error information if present
                if err != nil </span><span class="cov1" title="1">{
                        grpcStatus := status.Convert(err)
                        responseEntry = responseEntry.With(
                                "error_code", grpcStatus.Code().String(),
                                "error_message", grpcStatus.Message(),
                        )
                }</span>

                // Add response payload if enabled and no error
                <span class="cov6" title="5">if l.config.LogResponses &amp;&amp; err == nil &amp;&amp; l.config.LogPayloads </span><span class="cov0" title="0">{
                        responseEntry = responseEntry.With("response_payload", resp)
                }</span>

                // Log the response
                <span class="cov6" title="5">responseEntry.Log(ctx, logLevel, "gRPC request completed")

                return resp, err</span>
        }
}

// StreamServerInterceptor returns a gRPC stream server interceptor for logging.
func (l *LoggingInterceptor) StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov4" title="3">{
        return func(
                srv interface{},
                ss grpc.ServerStream,
                info *grpc.StreamServerInfo,
                handler grpc.StreamHandler,
        ) error </span><span class="cov1" title="1">{
                // Check if method should be excluded from logging
                if l.shouldExcludeMethod(info.FullMethod) </span><span class="cov0" title="0">{
                        return handler(srv, ss)
                }</span>

                <span class="cov1" title="1">start := time.Now()
                ctx := ss.Context()

                // Extract identity and request information
                logEntry := l.createBaseLogEntry(ctx, info.FullMethod, "stream")

                // Log stream start
                if l.config.LogRequests </span><span class="cov1" title="1">{
                        logEntry.With("event", "stream_started").Info("gRPC stream started")
                }</span>

                // Wrap the stream to count messages
                <span class="cov1" title="1">wrappedStream := &amp;loggingServerStream{
                        ServerStream: ss,
                        logger:       l.logger,
                        method:       info.FullMethod,
                        logPayloads:  l.config.LogPayloads,
                }

                // Call the handler
                err := handler(srv, wrappedStream)

                duration := time.Since(start)

                // Determine log level
                logLevel := slog.LevelInfo
                if err != nil </span><span class="cov0" title="0">{
                        logLevel = slog.LevelError
                }</span> else<span class="cov1" title="1"> if duration &gt; l.config.SlowRequestThreshold </span><span class="cov0" title="0">{
                        logLevel = slog.LevelWarn
                }</span>

                // Create completion log entry
                <span class="cov1" title="1">completionEntry := logEntry.With(
                        "event", "stream_completed",
                        "duration_ms", duration.Milliseconds(),
                        "success", err == nil,
                        "messages_sent", wrappedStream.messagesSent,
                        "messages_received", wrappedStream.messagesReceived,
                )

                // Add error information if present
                if err != nil </span><span class="cov0" title="0">{
                        grpcStatus := status.Convert(err)
                        completionEntry = completionEntry.With(
                                "error_code", grpcStatus.Code().String(),
                                "error_message", grpcStatus.Message(),
                        )
                }</span>

                // Log stream completion
                <span class="cov1" title="1">completionEntry.Log(ctx, logLevel, "gRPC stream completed")

                return err</span>
        }
}

// loggingServerStream wraps a grpc.ServerStream to log message flow.
type loggingServerStream struct {
        grpc.ServerStream
        logger           *slog.Logger
        method           string
        logPayloads      bool
        messagesSent     int
        messagesReceived int
}

// SendMsg logs outgoing messages.
func (s *loggingServerStream) SendMsg(m interface{}) error <span class="cov3" title="2">{
        err := s.ServerStream.SendMsg(m)
        if err == nil </span><span class="cov1" title="1">{
                s.messagesSent++
                if s.logPayloads </span><span class="cov1" title="1">{
                        s.logger.Debug("Stream message sent",
                                "method", s.method,
                                "message_count", s.messagesSent,
                                "payload", m)
                }</span>
        }
        <span class="cov3" title="2">if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to send message: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// RecvMsg logs incoming messages.
func (s *loggingServerStream) RecvMsg(m interface{}) error <span class="cov1" title="1">{
        err := s.ServerStream.RecvMsg(m)
        if err == nil </span><span class="cov1" title="1">{
                s.messagesReceived++
                if s.logPayloads </span><span class="cov0" title="0">{
                        s.logger.Debug("Stream message received",
                                "method", s.method,
                                "message_count", s.messagesReceived,
                                "payload", m)
                }</span>
        }
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to receive message: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// createBaseLogEntry creates a base log entry with common fields.
func (l *LoggingInterceptor) createBaseLogEntry(ctx context.Context, method, requestType string) *slog.Logger <span class="cov6" title="6">{
        entry := l.logger.With(
                "method", method,
                "request_type", requestType,
                "timestamp", time.Now().Unix(),
        )

        // Add identity information if available
        if identity, ok := GetIdentityFromContext(ctx); ok </span><span class="cov1" title="1">{
                entry = entry.With(
                        "client_spiffe_id", identity.SPIFFEID,
                        "client_service", identity.ServiceName,
                        "client_trust_domain", identity.TrustDomain,
                )
        }</span>

        // Add propagated identity information
        <span class="cov6" title="6">if originalCaller, ok := GetOriginalCaller(ctx); ok </span><span class="cov1" title="1">{
                entry = entry.With("original_caller", originalCaller)
        }</span>

        <span class="cov6" title="6">if callChain, ok := GetCallChain(ctx); ok </span><span class="cov1" title="1">{
                entry = entry.With("call_chain", callChain)
        }</span>

        <span class="cov6" title="6">if requestID, ok := GetRequestID(ctx); ok </span><span class="cov1" title="1">{
                entry = entry.With("request_id", requestID)
        }</span>

        <span class="cov6" title="6">return entry</span>
}

// shouldExcludeMethod checks if a method should be excluded from logging.
func (l *LoggingInterceptor) shouldExcludeMethod(method string) bool <span class="cov9" title="15">{
        for _, excludeMethod := range l.config.ExcludeMethods </span><span class="cov8" title="11">{
                if method == excludeMethod </span><span class="cov6" title="5">{
                        return true
                }</span>
        }
        <span class="cov8" title="10">return false</span>
}

// DefaultLoggingConfig returns a default logging configuration.
func DefaultLoggingConfig() *LoggingConfig <span class="cov8" title="11">{
        return &amp;LoggingConfig{
                Logger:               nil, // Will use secure logger
                LogRequests:          true,
                LogResponses:         true,
                LogPayloads:          false, // Disabled by default for security
                SlowRequestThreshold: defaultSlowThreshold,
                ExcludeMethods: []string{
                        "/grpc.health.v1.Health/Check",
                        "/grpc.health.v1.Health/Watch",
                },
                IncludeHeaders: []string{},
        }
}</span>

// NewSecureLoggingConfig creates a logging config with payload logging disabled for security.
func NewSecureLoggingConfig() *LoggingConfig <span class="cov6" title="6">{
        config := DefaultLoggingConfig()
        config.LogPayloads = false // Ensure payloads are not logged
        return config
}</span>

// NewDebugLoggingConfig creates a logging config suitable for development/debugging.
func NewDebugLoggingConfig() *LoggingConfig <span class="cov4" title="3">{
        config := DefaultLoggingConfig()
        config.LogPayloads = true
        config.SlowRequestThreshold = debugSlowThreshold
        config.ExcludeMethods = []string{} // Log everything in debug mode
        return config
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package interceptors

import (
        "context"
        "fmt"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const defaultResultCode = "success"

// MetricsCollector defines the interface for collecting gRPC metrics.
type MetricsCollector interface {
        // IncRequestsTotal increments the total number of requests
        IncRequestsTotal(method, service, code string)

        // ObserveRequestDuration records request duration
        ObserveRequestDuration(method, service, code string, duration time.Duration)

        // IncActiveRequests increments active requests counter
        IncActiveRequests(method, service string)

        // DecActiveRequests decrements active requests counter
        DecActiveRequests(method, service string)

        // IncStreamMessagesTotal increments stream message counter
        IncStreamMessagesTotal(method, service, direction string)

        // IncAuthenticationTotal increments authentication attempts
        IncAuthenticationTotal(service, result string)

        // ObservePayloadSize records payload sizes
        ObservePayloadSize(method, service, direction string, size int)
}

// DefaultMetricsCollector provides a no-op implementation.
type DefaultMetricsCollector struct{}

// IncRequestsTotal is a no-op implementation.
func (d *DefaultMetricsCollector) IncRequestsTotal(_, _, _ string) {<span class="cov1" title="1">}</span>

// ObserveRequestDuration is a no-op implementation.
func (d *DefaultMetricsCollector) ObserveRequestDuration(_, _, _ string, _ time.Duration) {<span class="cov1" title="1">}</span>

// IncActiveRequests is a no-op implementation.
func (d *DefaultMetricsCollector) IncActiveRequests(_, _ string) {<span class="cov1" title="1">}</span>

// DecActiveRequests is a no-op implementation.
func (d *DefaultMetricsCollector) DecActiveRequests(_, _ string) {<span class="cov1" title="1">}</span>

// IncStreamMessagesTotal is a no-op implementation.
func (d *DefaultMetricsCollector) IncStreamMessagesTotal(_, _, _ string) {<span class="cov1" title="1">}</span>

// IncAuthenticationTotal is a no-op implementation.
func (d *DefaultMetricsCollector) IncAuthenticationTotal(_, _ string) {<span class="cov1" title="1">}</span>

// ObservePayloadSize is a no-op implementation.
func (d *DefaultMetricsCollector) ObservePayloadSize(_, _, _ string, _ int) {<span class="cov1" title="1">}</span>

// MetricsConfig configures metrics collection behavior.
type MetricsConfig struct {
        // MetricsCollector to use for collecting metrics
        MetricsCollector MetricsCollector

        // ServiceName to use in metrics labels
        ServiceName string

        // EnablePayloadSize enables payload size metrics collection
        EnablePayloadSize bool

        // EnableActiveRequests enables active requests tracking
        EnableActiveRequests bool
}

// MetricsInterceptor provides metrics collection for gRPC services.
type MetricsInterceptor struct {
        config *MetricsConfig
}

// NewMetricsInterceptor creates a new metrics interceptor.
func NewMetricsInterceptor(config *MetricsConfig) *MetricsInterceptor <span class="cov9" title="10">{
        if config.MetricsCollector == nil </span><span class="cov3" title="2">{
                config.MetricsCollector = &amp;DefaultMetricsCollector{}
        }</span>

        <span class="cov9" title="10">return &amp;MetricsInterceptor{
                config: config,
        }</span>
}

// UnaryServerInterceptor returns a gRPC unary server interceptor for metrics collection.
func (m *MetricsInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov4" title="3">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov4" title="3">{
                start := time.Now()
                method := info.FullMethod
                service := m.config.ServiceName

                // Track active requests
                if m.config.EnableActiveRequests </span><span class="cov1" title="1">{
                        m.config.MetricsCollector.IncActiveRequests(method, service)
                        defer m.config.MetricsCollector.DecActiveRequests(method, service)
                }</span>

                // Track payload size if enabled
                <span class="cov4" title="3">if m.config.EnablePayloadSize </span><span class="cov1" title="1">{
                        if size := estimatePayloadSize(req); size &gt; 0 </span><span class="cov1" title="1">{
                                m.config.MetricsCollector.ObservePayloadSize(method, service, "request", size)
                        }</span>
                }

                // Call the handler
                <span class="cov4" title="3">resp, err := handler(ctx, req)

                // Calculate duration
                duration := time.Since(start)

                // Determine status code
                code := codes.OK
                if err != nil </span><span class="cov1" title="1">{
                        code = status.Code(err)
                }</span>

                // Collect metrics
                <span class="cov4" title="3">codeStr := code.String()
                m.config.MetricsCollector.IncRequestsTotal(method, service, codeStr)
                m.config.MetricsCollector.ObserveRequestDuration(method, service, codeStr, duration)

                // Track response payload size if enabled and no error
                if m.config.EnablePayloadSize &amp;&amp; err == nil </span><span class="cov1" title="1">{
                        if size := estimatePayloadSize(resp); size &gt; 0 </span><span class="cov1" title="1">{
                                m.config.MetricsCollector.ObservePayloadSize(method, service, "response", size)
                        }</span>
                }

                // Track authentication metrics if identity is available
                <span class="cov4" title="3">if identity, ok := GetIdentityFromContext(ctx); ok </span><span class="cov1" title="1">{
                        result := defaultResultCode
                        if err != nil </span><span class="cov0" title="0">{
                                result = "failure"
                        }</span>
                        <span class="cov1" title="1">m.config.MetricsCollector.IncAuthenticationTotal(identity.ServiceName, result)</span>
                }

                <span class="cov4" title="3">return resp, err</span>
        }
}

// StreamServerInterceptor returns a gRPC stream server interceptor for metrics collection.
func (m *MetricsInterceptor) StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov3" title="2">{
        return func(
                srv interface{},
                ss grpc.ServerStream,
                info *grpc.StreamServerInfo,
                handler grpc.StreamHandler,
        ) error </span><span class="cov0" title="0">{
                start := time.Now()
                method := info.FullMethod
                service := m.config.ServiceName
                ctx := ss.Context()

                // Track active requests
                if m.config.EnableActiveRequests </span><span class="cov0" title="0">{
                        m.config.MetricsCollector.IncActiveRequests(method, service)
                        defer m.config.MetricsCollector.DecActiveRequests(method, service)
                }</span>

                // Wrap the stream to collect message metrics
                <span class="cov0" title="0">wrappedStream := &amp;metricsServerStream{
                        ServerStream: ss,
                        method:       method,
                        service:      service,
                        collector:    m.config.MetricsCollector,
                        enableSizes:  m.config.EnablePayloadSize,
                }

                // Call the handler
                err := handler(srv, wrappedStream)

                // Calculate duration
                duration := time.Since(start)

                // Determine status code
                code := codes.OK
                if err != nil </span><span class="cov0" title="0">{
                        code = status.Code(err)
                }</span>

                // Collect metrics
                <span class="cov0" title="0">codeStr := code.String()
                m.config.MetricsCollector.IncRequestsTotal(method, service, codeStr)
                m.config.MetricsCollector.ObserveRequestDuration(method, service, codeStr, duration)

                // Track authentication metrics if identity is available
                if identity, ok := GetIdentityFromContext(ctx); ok </span><span class="cov0" title="0">{
                        result := defaultResultCode
                        if err != nil </span><span class="cov0" title="0">{
                                result = "failure"
                        }</span>
                        <span class="cov0" title="0">m.config.MetricsCollector.IncAuthenticationTotal(identity.ServiceName, result)</span>
                }

                <span class="cov0" title="0">return err</span>
        }
}

// metricsServerStream wraps a grpc.ServerStream to collect message metrics.
type metricsServerStream struct {
        grpc.ServerStream
        method      string
        service     string
        collector   MetricsCollector
        enableSizes bool
}

// SendMsg collects metrics for outgoing messages.
func (s *metricsServerStream) SendMsg(m interface{}) error <span class="cov3" title="2">{
        err := s.ServerStream.SendMsg(m)
        if err == nil </span><span class="cov1" title="1">{
                s.collector.IncStreamMessagesTotal(s.method, s.service, "sent")

                if s.enableSizes </span><span class="cov1" title="1">{
                        if size := estimatePayloadSize(m); size &gt; 0 </span><span class="cov1" title="1">{
                                s.collector.ObservePayloadSize(s.method, s.service, "response", size)
                        }</span>
                }
        }
        <span class="cov3" title="2">if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to send message: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// RecvMsg collects metrics for incoming messages.
func (s *metricsServerStream) RecvMsg(m interface{}) error <span class="cov1" title="1">{
        err := s.ServerStream.RecvMsg(m)
        if err == nil </span><span class="cov1" title="1">{
                s.collector.IncStreamMessagesTotal(s.method, s.service, "received")

                if s.enableSizes </span><span class="cov0" title="0">{
                        if size := estimatePayloadSize(m); size &gt; 0 </span><span class="cov0" title="0">{
                                s.collector.ObservePayloadSize(s.method, s.service, "request", size)
                        }</span>
                }
        }
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to receive message: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Client-side interceptors

// UnaryClientInterceptor returns a gRPC unary client interceptor for metrics collection.
func (m *MetricsInterceptor) UnaryClientInterceptor() grpc.UnaryClientInterceptor <span class="cov1" title="1">{
        return func(
                ctx context.Context,
                method string,
                req, reply interface{},
                cc *grpc.ClientConn,
                invoker grpc.UnaryInvoker,
                opts ...grpc.CallOption,
        ) error </span><span class="cov1" title="1">{
                start := time.Now()
                service := m.config.ServiceName

                // Track active requests
                if m.config.EnableActiveRequests </span><span class="cov0" title="0">{
                        m.config.MetricsCollector.IncActiveRequests(method, service)
                        defer m.config.MetricsCollector.DecActiveRequests(method, service)
                }</span>

                // Track request payload size if enabled
                <span class="cov1" title="1">if m.config.EnablePayloadSize </span><span class="cov1" title="1">{
                        if size := estimatePayloadSize(req); size &gt; 0 </span><span class="cov1" title="1">{
                                m.config.MetricsCollector.ObservePayloadSize(method, service, "request", size)
                        }</span>
                }

                // Make the call
                <span class="cov1" title="1">err := invoker(ctx, method, req, reply, cc, opts...)

                // Calculate duration
                duration := time.Since(start)

                // Determine status code
                code := codes.OK
                if err != nil </span><span class="cov0" title="0">{
                        code = status.Code(err)
                }</span>

                // Collect metrics
                <span class="cov1" title="1">codeStr := code.String()
                m.config.MetricsCollector.IncRequestsTotal(method, service, codeStr)
                m.config.MetricsCollector.ObserveRequestDuration(method, service, codeStr, duration)

                // Track response payload size if enabled and no error
                if m.config.EnablePayloadSize &amp;&amp; err == nil </span><span class="cov1" title="1">{
                        if size := estimatePayloadSize(reply); size &gt; 0 </span><span class="cov1" title="1">{
                                m.config.MetricsCollector.ObservePayloadSize(method, service, "response", size)
                        }</span>
                }

                <span class="cov1" title="1">return err</span>
        }
}

// StreamClientInterceptor returns a gRPC stream client interceptor for metrics collection.
func (m *MetricsInterceptor) StreamClientInterceptor() grpc.StreamClientInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                desc *grpc.StreamDesc,
                cc *grpc.ClientConn,
                method string,
                streamer grpc.Streamer,
                opts ...grpc.CallOption,
        ) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                start := time.Now()
                service := m.config.ServiceName

                // Track active requests
                if m.config.EnableActiveRequests </span><span class="cov0" title="0">{
                        m.config.MetricsCollector.IncActiveRequests(method, service)
                        // Note: DecActiveRequests will be called when stream is closed
                }</span>

                // Create the stream
                <span class="cov0" title="0">clientStream, err := streamer(ctx, desc, cc, method, opts...)
                if err != nil </span><span class="cov0" title="0">{
                        if m.config.EnableActiveRequests </span><span class="cov0" title="0">{
                                m.config.MetricsCollector.DecActiveRequests(method, service)
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }

                // Wrap the stream for metrics collection
                <span class="cov0" title="0">wrappedStream := &amp;metricsClientStream{
                        ClientStream: clientStream,
                        method:       method,
                        service:      service,
                        collector:    m.config.MetricsCollector,
                        enableSizes:  m.config.EnablePayloadSize,
                        start:        start,
                        enableActive: m.config.EnableActiveRequests,
                }

                return wrappedStream, nil</span>
        }
}

// metricsClientStream wraps a grpc.ClientStream to collect message metrics.
type metricsClientStream struct {
        grpc.ClientStream
        method       string
        service      string
        collector    MetricsCollector
        enableSizes  bool
        start        time.Time
        enableActive bool
        closed       bool
}

// SendMsg collects metrics for outgoing messages.
func (s *metricsClientStream) SendMsg(m interface{}) error <span class="cov0" title="0">{
        err := s.ClientStream.SendMsg(m)
        if err == nil </span><span class="cov0" title="0">{
                s.collector.IncStreamMessagesTotal(s.method, s.service, "sent")

                if s.enableSizes </span><span class="cov0" title="0">{
                        if size := estimatePayloadSize(m); size &gt; 0 </span><span class="cov0" title="0">{
                                s.collector.ObservePayloadSize(s.method, s.service, "request", size)
                        }</span>
                }
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send message: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RecvMsg collects metrics for incoming messages.
func (s *metricsClientStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        err := s.ClientStream.RecvMsg(m)
        if err == nil </span><span class="cov0" title="0">{
                s.collector.IncStreamMessagesTotal(s.method, s.service, "received")

                if s.enableSizes </span><span class="cov0" title="0">{
                        if size := estimatePayloadSize(m); size &gt; 0 </span><span class="cov0" title="0">{
                                s.collector.ObservePayloadSize(s.method, s.service, "response", size)
                        }</span>
                }
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to receive message: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CloseSend collects final metrics when the stream is closed.
func (s *metricsClientStream) CloseSend() error <span class="cov0" title="0">{
        err := s.ClientStream.CloseSend()
        s.collectFinalMetrics(err)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close send: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// collectFinalMetrics collects metrics when the stream ends.
func (s *metricsClientStream) collectFinalMetrics(err error) <span class="cov0" title="0">{
        if s.closed </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.closed = true

        // Calculate duration
        duration := time.Since(s.start)

        // Determine status code
        code := codes.OK
        if err != nil </span><span class="cov0" title="0">{
                code = status.Code(err)
        }</span>

        // Collect final metrics
        <span class="cov0" title="0">codeStr := code.String()
        s.collector.IncRequestsTotal(s.method, s.service, codeStr)
        s.collector.ObserveRequestDuration(s.method, s.service, codeStr, duration)

        // Decrement active requests
        if s.enableActive </span><span class="cov0" title="0">{
                s.collector.DecActiveRequests(s.method, s.service)
        }</span>
}

// estimatePayloadSize estimates the size of a payload.
// This is a simple implementation that could be enhanced with more accurate sizing.
func estimatePayloadSize(payload interface{}) int <span class="cov10" title="12">{
        if payload == nil </span><span class="cov3" title="2">{
                return 0
        }</span>

        // This is a simplified estimation - in practice you might want to use
        // protocol buffer's Size() method or other serialization-specific methods
        <span class="cov9" title="10">switch v := payload.(type) </span>{
        case string:<span class="cov8" title="7">
                return len(v)</span>
        case []byte:<span class="cov3" title="2">
                return len(v)</span>
        default:<span class="cov1" title="1">
                // Rough estimate - could be enhanced with reflection or proto.Size()
                const defaultPayloadSize = 64
                return defaultPayloadSize</span> // Default estimate
        }
}

// DefaultMetricsConfig returns a default metrics configuration.
func DefaultMetricsConfig(serviceName string) *MetricsConfig <span class="cov6" title="4">{
        return &amp;MetricsConfig{
                MetricsCollector:     &amp;DefaultMetricsCollector{},
                ServiceName:          serviceName,
                EnablePayloadSize:    false, // Disabled by default for performance
                EnableActiveRequests: true,
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package logging provides secure logging utilities with automatic redaction of sensitive data.
package logging

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
)

// RedactedValue is the placeholder for redacted sensitive data.
const RedactedValue = "[REDACTED]"

// RedactorHandler wraps an slog.Handler to automatically redact sensitive fields.
type RedactorHandler struct {
        handler         slog.Handler
        sensitiveFields map[string]bool
}

// NewRedactorHandler creates a new handler that redacts sensitive fields.
func NewRedactorHandler(handler slog.Handler) *RedactorHandler <span class="cov3" title="5">{
        return &amp;RedactorHandler{
                handler: handler,
                sensitiveFields: map[string]bool{
                        "password":      true,
                        "secret":        true,
                        "token":         true,
                        "key":           true,
                        "private_key":   true,
                        "privatekey":    true,
                        "private-key":   true,
                        "cert":          true,
                        "certificate":   true,
                        "credentials":   true,
                        "auth":          true,
                        "bearer":        true,
                        "authorization": true,
                },
        }
}</span>

// Enabled implements slog.Handler.
func (h *RedactorHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov6" title="15">{
        return h.handler.Enabled(ctx, level)
}</span>

// Handle implements slog.Handler with sensitive data redaction.
//
//nolint:gocritic // Required by slog.Handler interface
func (h *RedactorHandler) Handle(ctx context.Context, record slog.Record) error <span class="cov6" title="15">{
        // Create a new record with redacted attributes
        newRecord := slog.Record{
                Time:    record.Time,
                Level:   record.Level,
                Message: record.Message,
                PC:      record.PC,
        }

        record.Attrs(func(attr slog.Attr) bool </span><span class="cov6" title="16">{
                newRecord.AddAttrs(h.redactAttr(attr))
                return true
        }</span>)

        <span class="cov6" title="15">if err := h.handler.Handle(ctx, newRecord); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redactor handle failed: %w", err)
        }</span>
        <span class="cov6" title="15">return nil</span>
}

// WithAttrs implements slog.Handler.
func (h *RedactorHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        redactedAttrs := make([]slog.Attr, len(attrs))
        for i, attr := range attrs </span><span class="cov0" title="0">{
                redactedAttrs[i] = h.redactAttr(attr)
        }</span>
        <span class="cov0" title="0">return &amp;RedactorHandler{handler: h.handler.WithAttrs(redactedAttrs)}</span>
}

// WithGroup implements slog.Handler.
func (h *RedactorHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;RedactorHandler{handler: h.handler.WithGroup(name)}
}</span>

// redactAttr redacts sensitive attributes recursively.
func (h *RedactorHandler) redactAttr(attr slog.Attr) slog.Attr <span class="cov6" title="18">{
        // Check if this field should be redacted
        if h.isSensitiveField(attr.Key) </span><span class="cov5" title="11">{
                return slog.Attr{
                        Key:   attr.Key,
                        Value: slog.StringValue(RedactedValue),
                }
        }</span>

        // Handle group attributes recursively
        <span class="cov4" title="7">if attr.Value.Kind() == slog.KindGroup </span><span class="cov1" title="1">{
                group := attr.Value.Group()
                redactedAttrs := make([]slog.Attr, len(group))
                for i, groupAttr := range group </span><span class="cov2" title="2">{
                        redactedAttrs[i] = h.redactAttr(groupAttr)
                }</span>
                <span class="cov1" title="1">return slog.Attr{
                        Key:   attr.Key,
                        Value: slog.GroupValue(redactedAttrs...),
                }</span>
        }

        // Handle string values that might contain sensitive patterns
        <span class="cov4" title="6">if attr.Value.Kind() == slog.KindString </span><span class="cov3" title="5">{
                return slog.Attr{
                        Key:   attr.Key,
                        Value: slog.StringValue(h.redactSensitiveStrings(attr.Value.String())),
                }
        }</span>

        <span class="cov1" title="1">return attr</span>
}

// isSensitiveField checks if a field name indicates sensitive data.
func (h *RedactorHandler) isSensitiveField(fieldName string) bool <span class="cov6" title="18">{
        lower := strings.ToLower(fieldName)

        // Direct match
        if h.sensitiveFields[lower] </span><span class="cov3" title="5">{
                return true
        }</span>

        // Pattern matching for compound field names
        <span class="cov5" title="13">for sensitive := range h.sensitiveFields </span><span class="cov10" title="128">{
                if strings.Contains(lower, sensitive) </span><span class="cov4" title="6">{
                        return true
                }</span>
        }

        <span class="cov4" title="7">return false</span>
}

// redactSensitiveStrings redacts sensitive patterns in string values.
func (h *RedactorHandler) redactSensitiveStrings(value string) string <span class="cov3" title="5">{
        // Redact certificate content (PEM format)
        if strings.Contains(value, "BEGIN CERTIFICATE") || strings.Contains(value, "BEGIN PRIVATE KEY") </span><span class="cov0" title="0">{
                return RedactedValue
        }</span>

        // Redact JWT tokens (basic pattern matching)
        <span class="cov3" title="5">if strings.Count(value, ".") &gt;= 2 &amp;&amp; len(value) &gt; 50 </span><span class="cov0" title="0">{
                // Looks like a JWT token
                return RedactedValue
        }</span>

        // Redact SPIFFE IDs that might contain sensitive service names in development
        // Note: SPIFFE IDs are generally not sensitive, but we can redact in debug contexts
        // This is configurable based on policy

        <span class="cov3" title="5">return value</span>
}

// NewSecureLogger creates a new slog.Logger with automatic sensitive data redaction.
func NewSecureLogger(handler slog.Handler) *slog.Logger <span class="cov0" title="0">{
        return slog.New(NewRedactorHandler(handler))
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package api provides high-level client and server APIs for secure SPIFFE-based communication.
package api

import (
        "context"
        "fmt"
        "net"
        "strings"
        "sync"

        "google.golang.org/grpc"

        "github.com/sufield/ephemos/internal/adapters/secondary/config"
        "github.com/sufield/ephemos/internal/adapters/secondary/spiffe"
        "github.com/sufield/ephemos/internal/adapters/secondary/transport"
        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
        "github.com/sufield/ephemos/internal/core/services"
)

// IdentityClient provides a high-level API for connecting to SPIFFE-secured services.
type IdentityClient struct {
        identityService *services.IdentityService
        domainClient    ports.Client
        mu              sync.Mutex
}

// NewIdentityClient creates a new IdentityClient with the given configuration file path.
func NewIdentityClient(ctx context.Context, configPath string) (*IdentityClient, error) <span class="cov10" title="4">{
        configProvider := config.NewFileProvider()

        var cfg *ports.Configuration
        var err error

        if configPath != "" </span><span class="cov1" title="1">{
                cfg, err = configProvider.LoadConfiguration(ctx, configPath)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to load configuration: %w", err)
                }</span>
        } else<span class="cov8" title="3"> {
                cfg = configProvider.GetDefaultConfiguration(ctx)
                if cfg == nil </span><span class="cov0" title="0">{
                        return nil, &amp;errors.ValidationError{
                                Field:   "configuration",
                                Value:   nil,
                                Message: "no configuration provided and no default configuration available",
                        }
                }</span>
        }

        <span class="cov8" title="3">spiffeProvider, err := spiffe.NewProvider(cfg.SPIFFE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SPIFFE provider: %w", err)
        }</span>

        <span class="cov8" title="3">transportProvider := transport.NewGRPCProvider(spiffeProvider)

        identityService, err := services.NewIdentityService(
                spiffeProvider,
                transportProvider,
                cfg,
        )
        if err != nil </span><span class="cov8" title="3">{
                return nil, fmt.Errorf("failed to create identity service: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;IdentityClient{
                identityService: identityService,
        }, nil</span>
}

// Connect establishes a secure connection to a remote service using SPIFFE identities.
func (c *IdentityClient) Connect(ctx context.Context, serviceName, address string) (*ClientConnection, error) <span class="cov0" title="0">{
        // Input validation
        if ctx == nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "context",
                        Value:   nil,
                        Message: "context cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(serviceName) == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "serviceName",
                        Value:   serviceName,
                        Message: "service name cannot be empty or whitespace",
                }
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(address) == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "address",
                        Value:   address,
                        Message: "address cannot be empty or whitespace",
                }
        }</span>

        // Validate address format (host:port)
        <span class="cov0" title="0">if _, _, err := net.SplitHostPort(address); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "address",
                        Value:   address,
                        Message: "address must be in format 'host:port'",
                }
        }</span>

        <span class="cov0" title="0">serviceName = strings.TrimSpace(serviceName)
        address = strings.TrimSpace(address)

        // Thread-safe connection initialization
        c.mu.Lock()
        if c.domainClient == nil </span><span class="cov0" title="0">{
                client, err := c.identityService.CreateClientIdentity()
                if err != nil </span><span class="cov0" title="0">{
                        c.mu.Unlock()
                        return nil, fmt.Errorf("failed to create client identity: %w", err)
                }</span>
                <span class="cov0" title="0">c.domainClient = client</span>
        }
        <span class="cov0" title="0">c.mu.Unlock()

        domainConn, err := c.domainClient.Connect(serviceName, address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to service %s at %s: %w", serviceName, address, err)
        }</span>

        // Extract the underlying gRPC connection
        <span class="cov0" title="0">grpcConn, ok := domainConn.GetClientConnection().(*grpc.ClientConn)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected connection type from domain client")
        }</span>

        <span class="cov0" title="0">return &amp;ClientConnection{conn: grpcConn, domainConn: domainConn}, nil</span>
}

// Close cleans up the client resources and closes any connections.
func (c *IdentityClient) Close() error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.domainClient != nil </span><span class="cov0" title="0">{
                if err := c.domainClient.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close domain client: %w", err)
                }</span>
                <span class="cov0" title="0">c.domainClient = nil</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ClientConnection represents a secure client connection to a remote service.
type ClientConnection struct {
        conn       *grpc.ClientConn
        domainConn ports.Connection
}

// Close terminates the client connection and cleans up resources.
func (c *ClientConnection) Close() error <span class="cov0" title="0">{
        if c.domainConn != nil </span><span class="cov0" title="0">{
                if err := c.domainConn.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close domain connection: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetClientConnection returns the underlying gRPC client connection.
func (c *ClientConnection) GetClientConnection() *grpc.ClientConn <span class="cov0" title="0">{
        return c.conn
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package api

import (
        "context"
        "fmt"
        "log/slog"
        "net"
        "sync"

        "google.golang.org/grpc"

        "github.com/sufield/ephemos/internal/adapters/secondary/config"
        "github.com/sufield/ephemos/internal/adapters/secondary/spiffe"
        "github.com/sufield/ephemos/internal/adapters/secondary/transport"
        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
        "github.com/sufield/ephemos/internal/core/services"
)

// IdentityServer provides a secure gRPC server with SPIFFE-based identity management.
type IdentityServer struct {
        identityService *services.IdentityService
        configProvider  ports.ConfigurationProvider
        serviceName     string
        domainServer    ports.Server
        mu              sync.Mutex
}

// NewIdentityServer creates a new identity server with the given configuration.
func NewIdentityServer(ctx context.Context, configPath string) (*IdentityServer, error) <span class="cov10" title="6">{
        configProvider := config.NewFileProvider()

        var cfg *ports.Configuration
        var err error
        if configPath != "" </span><span class="cov1" title="1">{
                cfg, err = configProvider.LoadConfiguration(ctx, configPath)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to load configuration: %w", err)
                }</span>
        } else<span class="cov9" title="5"> {
                cfg = configProvider.GetDefaultConfiguration(ctx)
                if cfg == nil </span><span class="cov0" title="0">{
                        return nil, &amp;errors.ValidationError{
                                Field:   "configuration",
                                Value:   nil,
                                Message: "no configuration provided and no default configuration available",
                        }
                }</span>
        }

        <span class="cov9" title="5">spiffeProvider, err := spiffe.NewProvider(cfg.SPIFFE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SPIFFE provider: %w", err)
        }</span>

        <span class="cov9" title="5">transportProvider := transport.NewGRPCProvider(spiffeProvider)

        identityService, err := services.NewIdentityService(
                spiffeProvider,
                transportProvider,
                cfg,
        )
        if err != nil </span><span class="cov9" title="5">{
                return nil, fmt.Errorf("failed to create identity service: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;IdentityServer{
                identityService: identityService,
                configProvider:  configProvider,
                serviceName:     cfg.Service.Name,
        }, nil</span>
}

// RegisterService registers a gRPC service with the identity server.
func (s *IdentityServer) RegisterService(ctx context.Context, serviceRegistrar ServiceRegistrar) error <span class="cov0" title="0">{
        // Input validation
        if serviceRegistrar == nil </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "serviceRegistrar",
                        Value:   serviceRegistrar,
                        Message: "service registrar cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        if s.domainServer == nil </span><span class="cov0" title="0">{
                if err := s.initializeServer(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize server: %w", err)
                }</span>
        }

        // Adapt our ServiceRegistrar to ports.ServiceRegistrar
        <span class="cov0" title="0">portServiceRegistrar := &amp;serviceRegistrarAdapter{registrar: serviceRegistrar}
        if err := s.domainServer.RegisterService(portServiceRegistrar); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register service: %w", err)
        }</span>

        <span class="cov0" title="0">slog.Info("Service registered successfully", "service", s.serviceName)
        return nil</span>
}

// Serve starts the identity server on the provided listener.
func (s *IdentityServer) Serve(ctx context.Context, listener net.Listener) error <span class="cov0" title="0">{
        // Input validation
        if listener == nil </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "listener",
                        Value:   listener,
                        Message: "listener cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        if s.domainServer == nil </span><span class="cov0" title="0">{
                if err := s.initializeServer(ctx); err != nil </span><span class="cov0" title="0">{
                        s.mu.Unlock()
                        return fmt.Errorf("failed to initialize server: %w", err)
                }</span>
        }
        <span class="cov0" title="0">s.mu.Unlock()

        slog.Info("Server ready", "service", s.serviceName, "address", listener.Addr().String())

        // Adapt net.Listener to ports.Listener
        portListener := transport.NewNetListener(listener)
        if err := s.domainServer.Start(portListener); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve domain server: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Close gracefully shuts down the identity server.
func (s *IdentityServer) Close() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.domainServer != nil </span><span class="cov0" title="0">{
                if err := s.domainServer.Stop(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to stop server: %w", err)
                }</span>
                <span class="cov0" title="0">slog.Info("Server stopped gracefully", "service", s.serviceName)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *IdentityServer) initializeServer(_ context.Context) error <span class="cov0" title="0">{
        server, err := s.identityService.CreateServerIdentity()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create server identity: %w", err)
        }</span>
        <span class="cov0" title="0">s.domainServer = server
        slog.Info("Server identity created", "service", s.serviceName)
        return nil</span>
}

// serviceRegistrarAdapter adapts our API ServiceRegistrar to ports.ServiceRegistrar.
type serviceRegistrarAdapter struct {
        registrar ServiceRegistrar
}

func (a *serviceRegistrarAdapter) Register(server interface{}) <span class="cov0" title="0">{
        if grpcServer, ok := server.(*grpc.Server); ok </span><span class="cov0" title="0">{
                a.registrar.Register(grpcServer)
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package api

import (
        "context"
        "fmt"
        "sync"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// TestService is a simple gRPC service for testing purposes.
// It provides real functionality rather than mocks.
type TestService struct {
        UnimplementedTestServiceServer
        mu         sync.RWMutex
        callCount  int
        lastInput  string
        shouldFail bool
        failCode   codes.Code
}

// NewTestService creates a new test service with configurable behavior.
func NewTestService() *TestService <span class="cov0" title="0">{
        return &amp;TestService{
                failCode: codes.Internal,
        }
}</span>

// SetShouldFail configures the service to fail with the specified error code.
func (s *TestService) SetShouldFail(shouldFail bool, code codes.Code) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.shouldFail = shouldFail
        s.failCode = code
}</span>

// GetCallCount returns the number of times the service was called.
func (s *TestService) GetCallCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.callCount
}</span>

// GetLastInput returns the last input received by the service.
func (s *TestService) GetLastInput() string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.lastInput
}</span>

// TestMethod implements a simple test RPC method.
func (s *TestService) TestMethod(_ context.Context, req *TestRequest) (*TestResponse, error) <span class="cov0" title="0">{
        s.mu.Lock()
        s.callCount++
        s.lastInput = req.GetInput()
        shouldFail := s.shouldFail
        failCode := s.failCode
        s.mu.Unlock()

        if shouldFail </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("test service failure: %w", status.Error(failCode, "simulated failure"))
        }</span>

        <span class="cov0" title="0">return &amp;TestResponse{
                Output: "processed: " + req.GetInput(),
        }, nil</span>
}

// TestServiceRegistrar is a real implementation of ServiceRegistrar for testing.
// It registers a real gRPC service, not a mock.
type TestServiceRegistrar struct {
        service       *TestService
        registered    bool
        registerCount int
        mu            sync.Mutex
}

// NewTestServiceRegistrar creates a new test service registrar.
func NewTestServiceRegistrar(service *TestService) *TestServiceRegistrar <span class="cov0" title="0">{
        if service == nil </span><span class="cov0" title="0">{
                service = NewTestService()
        }</span>
        <span class="cov0" title="0">return &amp;TestServiceRegistrar{
                service: service,
        }</span>
}

// Register registers the test service with the gRPC server.
func (r *TestServiceRegistrar) Register(server *grpc.Server) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if server != nil </span><span class="cov0" title="0">{
                // In a real scenario, this would be:
                // RegisterTestServiceServer(server, r.service)
                // For now, we just track that it was called
                r.registered = true
                r.registerCount++
        }</span>
}

// IsRegistered returns whether the service has been registered.
func (r *TestServiceRegistrar) IsRegistered() bool <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        return r.registered
}</span>

// GetRegisterCount returns how many times Register was called.
func (r *TestServiceRegistrar) GetRegisterCount() int <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        return r.registerCount
}</span>

// GetService returns the underlying test service.
func (r *TestServiceRegistrar) GetService() *TestService <span class="cov0" title="0">{
        return r.service
}</span>

// TestRequest represents a test request message for gRPC testing.
type TestRequest struct {
        Input string
}

// GetInput returns the input field of the test request.
func (r *TestRequest) GetInput() string <span class="cov0" title="0">{
        if r != nil </span><span class="cov0" title="0">{
                return r.Input
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// TestResponse represents a test response message for gRPC testing.
type TestResponse struct {
        Output string
}

// GetOutput returns the output field of the test response.
func (r *TestResponse) GetOutput() string <span class="cov0" title="0">{
        if r != nil </span><span class="cov0" title="0">{
                return r.Output
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// UnimplementedTestServiceServer is a minimal implementation for forward compatibility.
type UnimplementedTestServiceServer struct{}

// TestMethod provides an unimplemented test method for forward compatibility.
func (UnimplementedTestServiceServer) TestMethod(context.Context, *TestRequest) (*TestResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method TestMethod not implemented")
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package cli provides command-line interface implementations for Ephemos
package cli

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/spiffe/go-spiffe/v2/spiffeid"

        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
)

// RegistrarConfig holds configuration for the Registrar.
type RegistrarConfig struct {
        SPIRESocketPath string
        SPIREServerPath string // Path to spire-server binary
        Logger          *slog.Logger
}

// Registrar handles service registration with SPIRE.
type Registrar struct {
        configProvider  ports.ConfigurationProvider
        spireSocketPath string
        spireServerPath string
        logger          *slog.Logger
}

// isValidPath validates that a path is safe to use.
func isValidPath(path string) bool <span class="cov5" title="4">{
        if path == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="4">cleanPath := filepath.Clean(path)
        // Prevent path traversal
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return false
        }</span>
        // Ensure it's within allowed paths for SPIRE
        <span class="cov5" title="4">allowedPaths := []string{"/usr/bin/", "/usr/local/bin/", "/opt/spire/bin/", "./bin/"}
        for _, allowed := range allowedPaths </span><span class="cov5" title="4">{
                if strings.HasPrefix(cleanPath, allowed) || cleanPath == "spire-server" || cleanPath == "echo" </span><span class="cov5" title="4">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isValidSocketPath validates that a socket path is safe to use.
func isValidSocketPath(path string) bool <span class="cov5" title="4">{
        if path == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="4">cleanPath := filepath.Clean(path)
        // Prevent path traversal
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return false
        }</span>
        // Must be a socket file (typically .sock extension or in /tmp)
        <span class="cov5" title="4">return strings.HasSuffix(cleanPath, ".sock") || strings.HasPrefix(cleanPath, "/tmp/") || strings.HasPrefix(cleanPath, "/var/run/")</span>
}

// isValidSelector validates that a selector is in the correct format.
func isValidSelector(selector string) bool <span class="cov5" title="4">{
        if selector == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        // Basic validation - selectors should be in format "type:key:value"
        <span class="cov5" title="4">parts := strings.Split(selector, ":")
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        // First part should be a known selector type
        <span class="cov5" title="4">validTypes := []string{"unix", "k8s", "docker"}
        for _, validType := range validTypes </span><span class="cov5" title="4">{
                if parts[0] == validType </span><span class="cov5" title="4">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// NewRegistrar creates a new Registrar with proper dependency injection.
func NewRegistrar(
        configProvider ports.ConfigurationProvider,
        config *RegistrarConfig,
) *Registrar <span class="cov10" title="16">{
        if config == nil </span><span class="cov6" title="5">{
                config = &amp;RegistrarConfig{}
        }</span>

        <span class="cov10" title="16">if config.SPIRESocketPath == "" </span><span class="cov9" title="12">{
                config.SPIRESocketPath = os.Getenv("SPIRE_SOCKET_PATH")
                if config.SPIRESocketPath == "" </span><span class="cov8" title="11">{
                        config.SPIRESocketPath = "/tmp/spire-server/private/api.sock"
                }</span>
        }

        <span class="cov10" title="16">if config.SPIREServerPath == "" </span><span class="cov6" title="6">{
                config.SPIREServerPath = "spire-server"
        }</span>

        <span class="cov10" title="16">if config.Logger == nil </span><span class="cov7" title="7">{
                config.Logger = slog.Default()
        }</span>

        <span class="cov10" title="16">return &amp;Registrar{
                configProvider:  configProvider,
                spireSocketPath: config.SPIRESocketPath,
                spireServerPath: config.SPIREServerPath,
                logger:          config.Logger,
        }</span>
}

// RegisterService registers a service with SPIRE based on its configuration.
func (r *Registrar) RegisterService(ctx context.Context, configPath string) error <span class="cov7" title="8">{
        r.logger.Info("Starting service registration", "configPath", configPath)

        cfg, err := r.configProvider.LoadConfiguration(ctx, configPath)
        if err != nil </span><span class="cov1" title="1">{
                r.logger.Error("Failed to load configuration", "error", err)
                return fmt.Errorf("failed to load configuration: %w", errors.NewDomainError(errors.ErrMissingConfiguration, err))
        }</span>

        <span class="cov7" title="7">if err := r.validateConfig(cfg); err != nil </span><span class="cov5" title="4">{
                r.logger.Error("Invalid configuration", "error", err)
                return err
        }</span>

        // Create SPIRE registration entry
        <span class="cov4" title="3">if err := r.createSPIREEntry(ctx, cfg); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to create SPIRE entry", "error", err)
                return fmt.Errorf("SPIFFE registration failed: %w", errors.NewDomainError(errors.ErrSPIFFERegistration, err))
        }</span>

        <span class="cov4" title="3">r.logger.Info("Service registration completed successfully",
                "service", cfg.Service.Name,
                "domain", cfg.Service.Domain)

        return nil</span>
}

// validateConfig performs comprehensive validation of the configuration.
func (r *Registrar) validateConfig(cfg *ports.Configuration) error <span class="cov9" title="14">{
        // Validate service name
        if cfg.Service.Name == "" </span><span class="cov3" title="2">{
                return &amp;errors.ValidationError{
                        Field:   "Service.Name",
                        Value:   cfg.Service.Name,
                        Message: "service name is required",
                }
        }</span>

        // Validate service name format (alphanumeric with hyphens)
        <span class="cov9" title="12">validName := regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$`)
        if !validName.MatchString(cfg.Service.Name) </span><span class="cov4" title="3">{
                return &amp;errors.ValidationError{
                        Field:   "Service.Name",
                        Value:   cfg.Service.Name,
                        Message: "service name must be alphanumeric with optional hyphens",
                }
        }</span>

        // Validate domain
        <span class="cov8" title="9">if cfg.Service.Domain == "" </span><span class="cov3" title="2">{
                return &amp;errors.ValidationError{
                        Field:   "Service.Domain",
                        Value:   cfg.Service.Domain,
                        Message: "service domain is required",
                }
        }</span>

        // Validate domain format (basic DNS name validation)
        <span class="cov7" title="7">validDomain := regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9-.]*[a-zA-Z0-9])?$`)
        if !validDomain.MatchString(cfg.Service.Domain) </span><span class="cov1" title="1">{
                return &amp;errors.ValidationError{
                        Field:   "Service.Domain",
                        Value:   cfg.Service.Domain,
                        Message: "service domain must be a valid DNS name",
                }
        }</span>

        <span class="cov6" title="6">return nil</span>
}

// createSPIREEntry creates a registration entry in SPIRE.
// NOTE: In production, you should use the SPIRE Server API directly via gRPC
// This implementation uses the CLI for simplicity, as the SPIRE Server API
// requires additional proto definitions not included in go-spiffe
//
//nolint:cyclop,funlen // Function has inherent complexity from validation and command execution
func (r *Registrar) createSPIREEntry(ctx context.Context, cfg *ports.Configuration) error <span class="cov5" title="4">{
        // Build SPIFFE IDs
        spiffeID, err := spiffeid.FromString(fmt.Sprintf("spiffe://%s/%s", cfg.Service.Domain, cfg.Service.Name))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse SPIFFE ID: %w", err)
        }</span>

        <span class="cov5" title="4">parentID, err := spiffeid.FromString(fmt.Sprintf("spiffe://%s/spire-agent", cfg.Service.Domain))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse parent ID: %w", err)
        }</span>

        // Get service selector
        <span class="cov5" title="4">selector := r.getServiceSelector()

        r.logger.Debug("Creating SPIRE entry",
                "spiffeID", spiffeID.String(),
                "parentID", parentID.String(),
                "selector", selector,
                "socketPath", r.spireSocketPath)

        // Validate paths for security
        if !isValidPath(r.spireServerPath) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid spire-server path: %s", r.spireServerPath)
        }</span>

        // Validate socket path for security
        <span class="cov5" title="4">if !isValidSocketPath(r.spireSocketPath) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid socket path: %s", r.spireSocketPath)
        }</span>

        // Validate selector format for security
        <span class="cov5" title="4">if !isValidSelector(selector) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid selector format: %s", selector)
        }</span>

        // Use spire-server CLI command
        // In production, use the SPIRE Server API directly
        //nolint:gosec // G204: Input is validated above for security
        <span class="cov5" title="4">cmd := exec.CommandContext(ctx, r.spireServerPath, "entry", "create",
                "-socketPath", r.spireSocketPath,
                "-spiffeID", spiffeID.String(),
                "-parentID", parentID.String(),
                "-selector", selector,
                "-ttl", "3600",
        )

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                outputStr := string(output)

                // Check if entry already exists (not an error)
                if strings.Contains(outputStr, "already exists") </span><span class="cov0" title="0">{
                        r.logger.Info("Registration entry already exists", "service", cfg.Service.Name)
                        return nil
                }</span>

                // Check for specific error conditions
                <span class="cov0" title="0">if strings.Contains(outputStr, "permission denied") </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission denied: ensure you have access to SPIRE socket at %s", r.spireSocketPath)
                }</span>

                <span class="cov0" title="0">if strings.Contains(outputStr, "connection refused") || strings.Contains(outputStr, "no such file") </span><span class="cov0" title="0">{
                        return fmt.Errorf("SPIRE server not running or not accessible at %s", r.spireSocketPath)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("SPIRE registration failed: %w\nOutput: %s", err, outputStr)</span>
        }

        <span class="cov5" title="4">r.logger.Info("Created SPIRE registration entry",
                "service", cfg.Service.Name,
                "output", string(output))

        return nil</span>
}

// getServiceSelector determines the service selector for SPIRE.
// For demo purposes, we use unix:uid selector (running as current user).
// In production, use more specific selectors like k8s:pod-label or unix:path.
func (r *Registrar) getServiceSelector() string <span class="cov6" title="5">{
        // For demo, use unix:uid selector with current user
        // This works when services run as the same user
        uid := os.Getuid()
        return fmt.Sprintf("unix:uid:%d", uid)
}</span>

// GetConfigProvider returns the configuration provider (for testing).
func (r *Registrar) GetConfigProvider() ports.ConfigurationProvider <span class="cov4" title="3">{
        return r.configProvider
}</span>

// GetSPIRESocketPath returns the SPIRE socket path (for testing).
func (r *Registrar) GetSPIRESocketPath() string <span class="cov5" title="4">{
        return r.spireSocketPath
}</span>

// GetSPIREServerPath returns the SPIRE server path (for testing).
func (r *Registrar) GetSPIREServerPath() string <span class="cov4" title="3">{
        return r.spireServerPath
}</span>

// ValidateConfig exposes validateConfig for testing.
func (r *Registrar) ValidateConfig(cfg *ports.Configuration) error <span class="cov7" title="7">{
        return r.validateConfig(cfg)
}</span>

// CreateSPIREEntry exposes createSPIREEntry for testing.
func (r *Registrar) CreateSPIREEntry(ctx context.Context, cfg *ports.Configuration) error <span class="cov1" title="1">{
        return r.createSPIREEntry(ctx, cfg)
}</span>

// GetServiceSelector exposes getServiceSelector for testing.
func (r *Registrar) GetServiceSelector() string <span class="cov1" title="1">{
        return r.getServiceSelector()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package config

import (
        "context"
        "fmt"
        "sync"

        "github.com/sufield/ephemos/internal/core/ports"
)

// InMemoryProvider is a real implementation of ConfigurationProvider that stores
// configurations in memory. This is useful for testing without mocks.
type InMemoryProvider struct {
        mu            sync.RWMutex
        configs       map[string]*ports.Configuration
        defaultConfig *ports.Configuration
}

// NewInMemoryProvider creates a new in-memory configuration provider.
func NewInMemoryProvider() *InMemoryProvider <span class="cov0" title="0">{
        return &amp;InMemoryProvider{
                configs: make(map[string]*ports.Configuration),
                defaultConfig: &amp;ports.Configuration{
                        Service: ports.ServiceConfig{
                                Name:   "default-service",
                                Domain: "default.org",
                        },
                        SPIFFE: &amp;ports.SPIFFEConfig{
                                SocketPath: "/tmp/spire-agent/public/api.sock",
                        },
                },
        }
}</span>

// SetConfiguration stores a configuration for a given path.
func (p *InMemoryProvider) SetConfiguration(path string, config *ports.Configuration) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.configs[path] = config
}</span>

// SetDefaultConfiguration updates the default configuration.
func (p *InMemoryProvider) SetDefaultConfiguration(config *ports.Configuration) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.defaultConfig = config
}</span>

// LoadConfiguration retrieves a configuration by path.
func (p *InMemoryProvider) LoadConfiguration(ctx context.Context, path string) (*ports.Configuration, error) <span class="cov0" title="0">{
        // Check for context cancellation
        if ctx != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, fmt.Errorf("context canceled: %w", ctx.Err())</span>
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">p.mu.RLock()
        defer p.mu.RUnlock()

        if path == "" </span><span class="cov0" title="0">{
                return p.defaultConfig, nil
        }</span>

        <span class="cov0" title="0">config, ok := p.configs[path]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration not found for path: %s", path)
        }</span>

        // Return a copy to prevent mutations
        <span class="cov0" title="0">return copyConfiguration(config), nil</span>
}

// GetDefaultConfiguration returns the default configuration.
func (p *InMemoryProvider) GetDefaultConfiguration(ctx context.Context) *ports.Configuration <span class="cov0" title="0">{
        // Check for context cancellation
        if ctx != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span> // Return nil on cancellation
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">p.mu.RLock()
        defer p.mu.RUnlock()
        return copyConfiguration(p.defaultConfig)</span>
}

// copyConfiguration creates a deep copy of a configuration.
func copyConfiguration(config *ports.Configuration) *ports.Configuration <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cfgCopy := &amp;ports.Configuration{
                Service: config.Service,
        }

        if config.SPIFFE != nil </span><span class="cov0" title="0">{
                cfgCopy.SPIFFE = &amp;ports.SPIFFEConfig{
                        SocketPath: config.SPIFFE.SocketPath,
                }
        }</span>

        <span class="cov0" title="0">if config.AuthorizedClients != nil </span><span class="cov0" title="0">{
                cfgCopy.AuthorizedClients = make([]string, len(config.AuthorizedClients))
                cfgCopy.AuthorizedClients = append(cfgCopy.AuthorizedClients, config.AuthorizedClients...)
        }</span>

        <span class="cov0" title="0">if config.TrustedServers != nil </span><span class="cov0" title="0">{
                cfgCopy.TrustedServers = make([]string, len(config.TrustedServers))
                cfgCopy.TrustedServers = append(cfgCopy.TrustedServers, config.TrustedServers...)
        }</span>

        <span class="cov0" title="0">return cfgCopy</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package config provides configuration management for Ephemos.
package config

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        yaml "gopkg.in/yaml.v3"

        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
)

// FileProvider provides configs from files.
type FileProvider struct{}

// NewFileProvider creates provider.
func NewFileProvider() *FileProvider <span class="cov7" title="4">{
        return &amp;FileProvider{}
}</span>

// LoadConfiguration loads config.
func (p *FileProvider) LoadConfiguration(ctx context.Context, path string) (*ports.Configuration, error) <span class="cov10" title="6">{
        // Validate and clean input path
        if strings.TrimSpace(path) == "" </span><span class="cov4" title="2">{
                return nil, &amp;errors.ValidationError{
                        Field:   "path",
                        Value:   path,
                        Message: "configuration file path cannot be empty or whitespace",
                }
        }</span>

        // Clean path first
        <span class="cov7" title="4">cleanPath := filepath.Clean(path)

        // Convert to absolute path to properly validate
        absPath, err := filepath.Abs(cleanPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve config file path: %w", err)
        }</span>

        // Use the absolute path for reading
        <span class="cov7" title="4">cleanPath = absPath

        // Check for context cancellation
        if ctx != nil </span><span class="cov7" title="4">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, fmt.Errorf("configuration loading canceled: %w", ctx.Err())</span>
                default:<span class="cov7" title="4"></span>
                }
        }

        <span class="cov7" title="4">data, err := os.ReadFile(cleanPath)
        if err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("failed to read config file %s: %w", path, err)
        }</span>

        <span class="cov4" title="2">var config ports.Configuration
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse config file %s: %w", path, err)
        }</span>

        // Validate the loaded configuration
        <span class="cov1" title="1">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration in file %s: %w", path, err)
        }</span>

        <span class="cov1" title="1">return &amp;config, nil</span>
}

// GetDefaultConfiguration gets default.
func (p *FileProvider) GetDefaultConfiguration(_ context.Context) *ports.Configuration <span class="cov6" title="3">{
        // GetDefaultConfiguration should always return a default configuration
        // regardless of context state, as it doesn't perform any blocking operations

        return &amp;ports.Configuration{
                Service: ports.ServiceConfig{
                        Name:   "ephemos-service", // Default service name
                        Domain: "",                // Empty domain uses SPIRE trust domain
                },
                SPIFFE: &amp;ports.SPIFFEConfig{
                        SocketPath: "/tmp/spire-agent/public/api.sock", // Standard SPIRE agent socket path
                },
                AuthorizedClients: []string{}, // Empty list - no client restrictions by default
                TrustedServers:    []string{}, // Empty list - trust all servers by default (not recommended for production)
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package memidentity provides an in-memory fake IdentityProvider for testing.
package memidentity

import (
        "crypto/x509"
        "sync"

        "github.com/sufield/ephemos/internal/core/domain"
        "github.com/sufield/ephemos/internal/core/ports"
)

// Provider is a fake in-memory IdentityProvider for testing.
type Provider struct {
        mu       sync.RWMutex
        identity *domain.ServiceIdentity
        cert     *domain.Certificate
        bundle   *domain.TrustBundle
        closed   bool
}

// New creates a new in-memory IdentityProvider with default test data.
func New() *Provider <span class="cov9" title="5">{
        // Create fake X.509 certificate for testing
        fakeCert := &amp;x509.Certificate{}

        return &amp;Provider{
                identity: &amp;domain.ServiceIdentity{
                        Name:   "test-service",
                        Domain: "example.com",
                        URI:    "spiffe://example.com/test-service",
                },
                cert: &amp;domain.Certificate{
                        Cert:       fakeCert,
                        PrivateKey: "fake-private-key",
                        Chain:      []*x509.Certificate{fakeCert},
                },
                bundle: &amp;domain.TrustBundle{
                        Certificates: []*x509.Certificate{fakeCert},
                },
        }
}</span>

// WithIdentity sets custom identity for testing.
func (p *Provider) WithIdentity(identity *domain.ServiceIdentity) *Provider <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.identity = identity
        return p
}</span>

// WithCertificate sets custom certificate for testing.
func (p *Provider) WithCertificate(cert *domain.Certificate) *Provider <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.cert = cert
        return p
}</span>

// GetServiceIdentity returns the configured service identity.
func (p *Provider) GetServiceIdentity() (*domain.ServiceIdentity, error) <span class="cov6" title="3">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        if p.closed </span><span class="cov0" title="0">{
                return nil, ports.ErrIdentityNotFound
        }</span>

        <span class="cov6" title="3">return p.identity, nil</span>
}

// GetCertificate returns the configured certificate.
func (p *Provider) GetCertificate() (*domain.Certificate, error) <span class="cov1" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        if p.closed </span><span class="cov0" title="0">{
                return nil, ports.ErrIdentityNotFound
        }</span>

        <span class="cov1" title="1">return p.cert, nil</span>
}

// GetTrustBundle returns the configured trust bundle.
func (p *Provider) GetTrustBundle() (*domain.TrustBundle, error) <span class="cov1" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        if p.closed </span><span class="cov0" title="0">{
                return nil, ports.ErrIdentityNotFound
        }</span>

        <span class="cov1" title="1">return p.bundle, nil</span>
}

// Close marks the provider as closed.
func (p *Provider) Close() error <span class="cov10" title="6">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.closed = true
        return nil
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package spiffe provides SPIFFE identity management and X.509 certificate handling.
package spiffe

import (
        "context"
        "fmt"
        "strings"

        "github.com/spiffe/go-spiffe/v2/spiffeid"
        "github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig"
        "github.com/spiffe/go-spiffe/v2/workloadapi"

        "github.com/sufield/ephemos/internal/core/domain"
        "github.com/sufield/ephemos/internal/core/ports"
)

// Provider provides SPIFFE identities.
type Provider struct {
        socketPath string
        x509Source *workloadapi.X509Source
}

// NewProvider creates a provider.
func NewProvider(config *ports.SPIFFEConfig) (*Provider, error) <span class="cov10" title="13">{
        if config == nil </span><span class="cov3" title="2">{
                // Use default socket path when no config is provided
                return &amp;Provider{
                        socketPath: "/tmp/spire-agent/public/api.sock",
                }, nil
        }</span>

        <span class="cov9" title="11">return &amp;Provider{
                socketPath: config.SocketPath,
        }, nil</span>
}

// GetServiceIdentity fetches identity.
func (p *Provider) GetServiceIdentity() (*domain.ServiceIdentity, error) <span class="cov0" title="0">{
        ctx := context.Background() // Context managed at adapter layer
        if err := p.ensureSource(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">svid, err := p.x509Source.GetX509SVID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get X509 SVID: %w", err)
        }</span>

        <span class="cov0" title="0">id := svid.ID
        serviceName := "unknown"
        path := id.Path()
        if path != "" &amp;&amp; len(path) &gt; 1 </span><span class="cov0" title="0">{
                // Remove leading slash and split by remaining slashes
                pathSegments := strings.Split(strings.TrimPrefix(path, "/"), "/")
                if len(pathSegments) &gt; 0 &amp;&amp; pathSegments[0] != "" </span><span class="cov0" title="0">{
                        serviceName = pathSegments[0]
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.ServiceIdentity{
                Name:   serviceName,
                Domain: id.TrustDomain().String(),
                URI:    id.String(),
        }, nil</span>
}

// GetCertificate fetches cert.
func (p *Provider) GetCertificate() (*domain.Certificate, error) <span class="cov0" title="0">{
        ctx := context.Background() // Context managed at adapter layer
        if err := p.ensureSource(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">svid, err := p.x509Source.GetX509SVID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get X509 SVID: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;domain.Certificate{
                Cert:       svid.Certificates[0],
                PrivateKey: svid.PrivateKey,
                Chain:      svid.Certificates,
        }, nil</span>
}

// GetTrustBundle fetches bundle.
func (p *Provider) GetTrustBundle() (*domain.TrustBundle, error) <span class="cov0" title="0">{
        ctx := context.Background() // Context managed at adapter layer
        if err := p.ensureSource(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">bundle, err := p.x509Source.GetX509BundleForTrustDomain(spiffeid.RequireTrustDomainFromString("example.org"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trust bundle: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;domain.TrustBundle{
                Certificates: bundle.X509Authorities(),
        }, nil</span>
}

func (p *Provider) ensureSource(ctx context.Context) error <span class="cov0" title="0">{
        if p.x509Source != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">source, err := workloadapi.NewX509Source(
                ctx,
                workloadapi.WithClientOptions(
                        workloadapi.WithAddr("unix://"+p.socketPath),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create X509 source: %w", err)
        }</span>

        <span class="cov0" title="0">p.x509Source = source
        return nil</span>
}

// GetTLSConfig gets TLS config.
func (p *Provider) GetTLSConfig(ctx context.Context) (tlsconfig.Authorizer, error) <span class="cov0" title="0">{
        if err := p.ensureSource(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tlsconfig.AuthorizeAny(), nil</span>
}

// GetX509Source returns source.
func (p *Provider) GetX509Source() *workloadapi.X509Source <span class="cov1" title="1">{
        return p.x509Source
}</span>

// GetSocketPath returns path.
func (p *Provider) GetSocketPath() string <span class="cov4" title="3">{
        return p.socketPath
}</span>

// Close closes the provider.
func (p *Provider) Close() error <span class="cov3" title="2">{
        if p.x509Source != nil </span><span class="cov0" title="0">{
                if err := p.x509Source.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close X509 source: %w", err)
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package transport provides enhanced gRPC connection management with backoff and retry policies.
package transport

import (
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/backoff"
        "google.golang.org/grpc/keepalive"
)

// Connection timeout constants.
const (
        defaultConnectTimeout        = 30 * time.Second
        developmentConnectTimeout    = 5 * time.Second
        highThroughputConnectTimeout = 10 * time.Second
)

// Backoff configuration constants.
const (
        defaultBackoffMultiplier   = 1.6
        defaultBackoffJitter       = 0.2
        defaultMaxBackoffDelay     = 120 * time.Second
        developmentMaxBackoffDelay = 10 * time.Second
        developmentBaseDelay       = 500 * time.Millisecond
)

// Keepalive constants.
const (
        defaultKeepaliveTime           = 10 * time.Second
        defaultKeepaliveTimeout        = 5 * time.Second
        highThroughputKeepaliveTime    = 30 * time.Second
        highThroughputKeepaliveTimeout = 10 * time.Second
)

// Idle timeout constants.
const (
        defaultIdleTimeout        = 30 * time.Minute
        developmentIdleTimeout    = 5 * time.Minute
        highThroughputIdleTimeout = 0 // Disabled
)

// Message size constants.
const (
        defaultMaxMessageSize        = 4 * 1024 * 1024  // 4MB
        highThroughputMaxMessageSize = 16 * 1024 * 1024 // 16MB
)

// Connection pool constants.
const (
        defaultPoolSize        = 5
        highThroughputPoolSize = 10
)

// ConnectionConfig provides configuration for gRPC client connections.
type ConnectionConfig struct {
        // Connection timeout for initial connection establishment
        ConnectTimeout time.Duration

        // Backoff configuration for connection retries
        BackoffConfig backoff.Config

        // Keepalive parameters for connection health
        KeepaliveParams keepalive.ClientParameters

        // Idle timeout for connections (0 disables idle timeout)
        IdleTimeout time.Duration

        // Maximum message sizes
        MaxRecvMsgSize int
        MaxSendMsgSize int

        // Enable connection pooling
        EnablePooling bool
        PoolSize      int

        // Service configuration for method-level settings
        ServiceConfig string
}

// DefaultConnectionConfig returns a production-ready connection configuration.
func DefaultConnectionConfig() *ConnectionConfig <span class="cov10" title="24">{
        return &amp;ConnectionConfig{
                ConnectTimeout: defaultConnectTimeout,
                BackoffConfig: backoff.Config{
                        BaseDelay:  1.0 * time.Second,
                        Multiplier: defaultBackoffMultiplier,
                        Jitter:     defaultBackoffJitter,
                        MaxDelay:   defaultMaxBackoffDelay,
                },
                KeepaliveParams: keepalive.ClientParameters{
                        Time:                defaultKeepaliveTime,
                        Timeout:             defaultKeepaliveTimeout,
                        PermitWithoutStream: true, // Send pings even without active streams
                },
                IdleTimeout:    defaultIdleTimeout,
                MaxRecvMsgSize: defaultMaxMessageSize,
                MaxSendMsgSize: defaultMaxMessageSize,
                EnablePooling:  false, // Disabled by default
                PoolSize:       defaultPoolSize,
                ServiceConfig: `{
                        "methodConfig": [
                                {
                                        "name": [{"service": ""}], 
                                        "retryPolicy": {
                                                "maxAttempts": 5,
                                                "initialBackoff": "1s",
                                                "maxBackoff": "30s",
                                                "backoffMultiplier": 2.0,
                                                "retryableStatusCodes": ["UNAVAILABLE", "DEADLINE_EXCEEDED", "ABORTED"]
                                        }
                                }
                        ]
                }`,
        }
}</span>

// DevelopmentConnectionConfig returns a configuration suitable for development.
func DevelopmentConnectionConfig() *ConnectionConfig <span class="cov6" title="6">{
        config := DefaultConnectionConfig()
        config.ConnectTimeout = developmentConnectTimeout
        config.BackoffConfig.BaseDelay = developmentBaseDelay
        config.BackoffConfig.MaxDelay = developmentMaxBackoffDelay
        config.IdleTimeout = developmentIdleTimeout
        config.ServiceConfig = `{
                "methodConfig": [
                        {
                                "name": [{"service": ""}],
                                "retryPolicy": {
                                        "maxAttempts": 3,
                                        "initialBackoff": "0.5s", 
                                        "maxBackoff": "5s",
                                        "backoffMultiplier": 1.5,
                                        "retryableStatusCodes": ["UNAVAILABLE"]
                                }
                        }
                ]
        }`
        return config
}</span>

// HighThroughputConnectionConfig returns a configuration optimized for high-throughput scenarios.
func HighThroughputConnectionConfig() *ConnectionConfig <span class="cov5" title="5">{
        config := DefaultConnectionConfig()
        config.ConnectTimeout = highThroughputConnectTimeout
        config.KeepaliveParams.Time = highThroughputKeepaliveTime       // Less frequent keepalives
        config.KeepaliveParams.Timeout = highThroughputKeepaliveTimeout // Longer timeout
        config.IdleTimeout = highThroughputIdleTimeout                  // Disable idle timeout
        config.MaxRecvMsgSize = highThroughputMaxMessageSize
        config.MaxSendMsgSize = highThroughputMaxMessageSize
        config.EnablePooling = true // Enable pooling for high throughput
        config.PoolSize = highThroughputPoolSize
        config.ServiceConfig = `{
                "methodConfig": [
                        {
                                "name": [{"service": ""}],
                                "retryPolicy": {
                                        "maxAttempts": 3,
                                        "initialBackoff": "2s",
                                        "maxBackoff": "60s", 
                                        "backoffMultiplier": 2.0,
                                        "retryableStatusCodes": ["UNAVAILABLE", "DEADLINE_EXCEEDED"]
                                }
                        }
                ]
        }`
        return config
}</span>

// ToDialOptions converts the connection configuration to gRPC dial options.
func (c *ConnectionConfig) ToDialOptions() []grpc.DialOption <span class="cov5" title="5">{
        options := []grpc.DialOption{
                grpc.WithConnectParams(grpc.ConnectParams{
                        Backoff:           c.BackoffConfig,
                        MinConnectTimeout: c.ConnectTimeout,
                }),
                grpc.WithKeepaliveParams(c.KeepaliveParams),
                grpc.WithDefaultServiceConfig(c.ServiceConfig),
                grpc.WithDefaultCallOptions(
                        grpc.MaxCallRecvMsgSize(c.MaxRecvMsgSize),
                        grpc.MaxCallSendMsgSize(c.MaxSendMsgSize),
                ),
        }

        // Add idle timeout if specified (0 disables idle timeout)
        if c.IdleTimeout &gt; 0 </span><span class="cov4" title="3">{
                options = append(options, grpc.WithIdleTimeout(c.IdleTimeout))
        }</span>

        <span class="cov5" title="5">return options</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package transport provides gRPC transport implementations for secure communication with
// advanced connection management, backoff strategies, and retry policies.
package transport

import (
        "context"
        "fmt"
        "log"
        "net"
        "sync"
        "time"

        "github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig"
        "google.golang.org/grpc"
        "google.golang.org/grpc/connectivity"
        "google.golang.org/grpc/credentials"

        "github.com/sufield/ephemos/internal/adapters/secondary/spiffe"
        "github.com/sufield/ephemos/internal/core/domain"
        "github.com/sufield/ephemos/internal/core/ports"
)

// GRPCProvider provides gRPC transport with advanced connection management.
type GRPCProvider struct {
        spiffeProvider   *spiffe.Provider
        connectionConfig *ConnectionConfig
}

// NewGRPCProvider creates a new provider with default connection configuration.
func NewGRPCProvider(spiffeProvider *spiffe.Provider) *GRPCProvider <span class="cov1" title="1">{
        return &amp;GRPCProvider{
                spiffeProvider:   spiffeProvider,
                connectionConfig: DefaultConnectionConfig(),
        }
}</span>

// NewGRPCProviderWithConfig creates a new provider with custom connection configuration.
func NewGRPCProviderWithConfig(spiffeProvider *spiffe.Provider, config *ConnectionConfig) *GRPCProvider <span class="cov10" title="3">{
        return &amp;GRPCProvider{
                spiffeProvider:   spiffeProvider,
                connectionConfig: config,
        }
}</span>

// CreateServer creates server transport implementing domain interface.
func (p *GRPCProvider) CreateServer(
        _ *domain.Certificate,
        _ *domain.TrustBundle,
        policy *domain.AuthenticationPolicy,
) (ports.Server, error) <span class="cov0" title="0">{
        source := p.spiffeProvider.GetX509Source()
        if source == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("X509 source not initialized")
        }</span>

        <span class="cov0" title="0">tlsConfig := tlsconfig.MTLSServerConfig(source, source, tlsconfig.AuthorizeAny())
        creds := credentials.NewTLS(tlsConfig)

        opts := []grpc.ServerOption{
                grpc.Creds(creds),
                grpc.UnaryInterceptor(p.createAuthInterceptor(policy)),
        }

        grpcServer := grpc.NewServer(opts...)

        return &amp;GRPCServer{
                server: grpcServer,
        }, nil</span>
}

// CreateClient creates client transport implementing domain interface with advanced connection management.
func (p *GRPCProvider) CreateClient(
        _ *domain.Certificate,
        _ *domain.TrustBundle,
        _ *domain.AuthenticationPolicy,
) (ports.Client, error) <span class="cov0" title="0">{
        source := p.spiffeProvider.GetX509Source()
        if source == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("X509 source not initialized")
        }</span>

        <span class="cov0" title="0">tlsConfig := tlsconfig.MTLSClientConfig(source, source, tlsconfig.AuthorizeAny())
        tlsConfig.ServerName = ""

        creds := credentials.NewTLS(tlsConfig)
        credentialOption := grpc.WithTransportCredentials(creds)

        client := &amp;GRPCClient{
                credentialOption: credentialOption,
                connectionConfig: p.connectionConfig,
                connectionPool:   make(map[string]*pooledConnection),
        }

        // Start background cleanup goroutine for connection pool if pooling is enabled
        if p.connectionConfig.EnablePooling </span><span class="cov0" title="0">{
                go client.poolCleanupRoutine()
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// Pool cleanup constants.
const (
        poolCleanupInterval = 30 * time.Second
        poolIdleTimeout     = 10 * time.Minute
)

// GRPCClient implements ports.Client for gRPC with advanced connection management.
type GRPCClient struct {
        credentialOption grpc.DialOption
        connectionConfig *ConnectionConfig
        connectionPool   map[string]*pooledConnection
        poolMutex        sync.RWMutex
}

// poolCleanupRoutine periodically cleans up unused pooled connections.
func (c *GRPCClient) poolCleanupRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(poolCleanupInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.cleanupIdleConnections()
        }</span>
}

func (c *GRPCClient) cleanupIdleConnections() <span class="cov0" title="0">{
        c.poolMutex.Lock()
        defer c.poolMutex.Unlock()

        now := time.Now()
        idleTimeout := poolIdleTimeout

        for key, pooled := range c.connectionPool </span><span class="cov0" title="0">{
                pooled.mutex.RLock()
                isIdle := pooled.inUse == 0 &amp;&amp; now.Sub(pooled.lastUsed) &gt; idleTimeout
                state := pooled.conn.GetState()
                pooled.mutex.RUnlock()

                // Remove connections that are idle too long or in bad state
                if isIdle || state == connectivity.Shutdown || state == connectivity.TransientFailure </span><span class="cov0" title="0">{
                        if err := pooled.conn.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("cleanup close error: %v", err)
                        }</span>
                        <span class="cov0" title="0">delete(c.connectionPool, key)</span>
                }
        }
}

// GRPCServer implements ports.Server for gRPC.
type GRPCServer struct {
        server *grpc.Server
}

// RegisterService registers a service with the gRPC server.
func (s *GRPCServer) RegisterService(serviceRegistrar ports.ServiceRegistrar) error <span class="cov0" title="0">{
        if serviceRegistrar == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service registrar cannot be nil")
        }</span>
        <span class="cov0" title="0">serviceRegistrar.Register(s.server)
        return nil</span>
}

// Start begins listening on the provided listener.
func (s *GRPCServer) Start(listener ports.Listener) error <span class="cov0" title="0">{
        if listener == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("listener cannot be nil")
        }</span>

        // Convert our domain listener to a net.Listener
        // We know NetListener wraps net.Listener, so extract it
        <span class="cov0" title="0">if netListener, ok := listener.(*NetListener); ok </span><span class="cov0" title="0">{
                if err := s.server.Serve(netListener.listener); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to serve: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("listener must be a NetListener wrapping net.Listener")</span>
}

// Stop gracefully shuts down the server.
func (s *GRPCServer) Stop() error <span class="cov0" title="0">{
        s.server.GracefulStop()
        return nil
}</span>

type pooledConnection struct {
        conn        *grpc.ClientConn
        serviceName string
        address     string
        lastUsed    time.Time
        inUse       int32
        mutex       sync.RWMutex
}

// Connect establishes a connection to a service with advanced connection management.
func (c *GRPCClient) Connect(serviceName, address string) (ports.Connection, error) <span class="cov0" title="0">{
        if serviceName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service name cannot be empty")
        }</span>
        <span class="cov0" title="0">if address == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("address cannot be empty")
        }</span>

        // Check if pooling is enabled
        <span class="cov0" title="0">if c.connectionConfig.EnablePooling </span><span class="cov0" title="0">{
                return c.getPooledConnection(serviceName, address)
        }</span>

        // Create a new connection with full configuration
        <span class="cov0" title="0">return c.createConnection(serviceName, address)</span>
}

func (c *GRPCClient) createConnection(serviceName, address string) (ports.Connection, error) <span class="cov0" title="0">{
        // Build dial options with connection configuration
        dialOptions := c.connectionConfig.ToDialOptions()
        dialOptions = append(dialOptions, c.credentialOption)

        // Create connection (dialing is lazy and handled via connection params)
        conn, err := grpc.NewClient(address, dialOptions...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create client for service %s at %s: %w", serviceName, address, err)
        }</span>

        <span class="cov0" title="0">return &amp;GRPCConnection{
                conn:        conn,
                serviceName: serviceName,
                address:     address,
        }, nil</span>
}

func (c *GRPCClient) getPooledConnection(serviceName, address string) (ports.Connection, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:%s", serviceName, address)

        c.poolMutex.Lock()
        defer c.poolMutex.Unlock()

        // Check if connection exists in pool
        if pooled, exists := c.connectionPool[key]; exists </span><span class="cov0" title="0">{
                pooled.mutex.RLock()
                state := pooled.conn.GetState()
                pooled.mutex.RUnlock()

                // If connection is healthy, reuse it
                if state == connectivity.Ready || state == connectivity.Idle </span><span class="cov0" title="0">{
                        pooled.mutex.Lock()
                        pooled.inUse++
                        pooled.lastUsed = time.Now()
                        pooled.mutex.Unlock()

                        return &amp;GRPCConnection{
                                conn:        pooled.conn,
                                serviceName: serviceName,
                                address:     address,
                                pooled:      pooled,
                        }, nil
                }</span>

                // Connection is unhealthy, remove from pool
                <span class="cov0" title="0">if err := pooled.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("cleanup close error: %v", err)
                }</span>
                <span class="cov0" title="0">delete(c.connectionPool, key)</span>
        }

        // Create new connection
        <span class="cov0" title="0">conn, err := c.createConnection(serviceName, address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add to pool
        <span class="cov0" title="0">grpcConn, ok := conn.(*GRPCConnection)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected *GRPCConnection, got %T", conn)
        }</span>
        <span class="cov0" title="0">pooled := &amp;pooledConnection{
                conn:        grpcConn.conn,
                serviceName: serviceName,
                address:     address,
                lastUsed:    time.Now(),
                inUse:       1,
        }

        c.connectionPool[key] = pooled
        grpcConn.pooled = pooled

        return conn, nil</span>
}

// Close releases client resources and closes all pooled connections.
func (c *GRPCClient) Close() error <span class="cov0" title="0">{
        c.poolMutex.Lock()
        defer c.poolMutex.Unlock()

        for key, pooled := range c.connectionPool </span><span class="cov0" title="0">{
                if err := pooled.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("cleanup close error: %v", err)
                }</span>
                <span class="cov0" title="0">delete(c.connectionPool, key)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GRPCConnection implements ports.Connection for gRPC with connection health monitoring.
type GRPCConnection struct {
        conn        *grpc.ClientConn
        serviceName string
        address     string
        pooled      *pooledConnection // nil if not pooled
}

// GetClientConnection returns the underlying gRPC connection.
func (c *GRPCConnection) GetClientConnection() interface{} <span class="cov0" title="0">{
        return c.conn
}</span>

// GetState returns the current connectivity state of the connection.
func (c *GRPCConnection) GetState() connectivity.State <span class="cov0" title="0">{
        return c.conn.GetState()
}</span>

// WaitForStateChange blocks until the connection state changes or context is canceled.
func (c *GRPCConnection) WaitForStateChange(ctx context.Context, sourceState connectivity.State) bool <span class="cov0" title="0">{
        return c.conn.WaitForStateChange(ctx, sourceState)
}</span>

// IsHealthy checks if the connection is in a healthy state.
func (c *GRPCConnection) IsHealthy() bool <span class="cov0" title="0">{
        state := c.conn.GetState()
        return state == connectivity.Ready || state == connectivity.Idle
}</span>

// Close closes the connection. For pooled connections, decrements usage counter.
func (c *GRPCConnection) Close() error <span class="cov0" title="0">{
        if c.pooled != nil </span><span class="cov0" title="0">{
                // This is a pooled connection, just decrement usage
                c.pooled.mutex.Lock()
                c.pooled.inUse--
                c.pooled.mutex.Unlock()
                return nil
        }</span>

        // This is a direct connection, close it
        <span class="cov0" title="0">if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close connection to %s at %s: %w", c.serviceName, c.address, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NetListener adapts net.Listener to ports.Listener.
type NetListener struct {
        listener net.Listener
}

// NewNetListener creates a new NetListener.
func NewNetListener(listener net.Listener) ports.Listener <span class="cov0" title="0">{
        return &amp;NetListener{listener: listener}
}</span>

// Accept waits for and returns the next connection.
func (l *NetListener) Accept() (interface{}, error) <span class="cov0" title="0">{
        conn, err := l.listener.Accept()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to accept connection: %w", err)
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

// Close closes the listener.
func (l *NetListener) Close() error <span class="cov0" title="0">{
        if err := l.listener.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close listener: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Addr returns the listener's network address.
func (l *NetListener) Addr() string <span class="cov0" title="0">{
        return l.listener.Addr().String()
}</span>

func (p *GRPCProvider) createAuthInterceptor(_ *domain.AuthenticationPolicy) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, _ *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                return handler(ctx, req)
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package app defines interfaces for core services and domain boundaries.
package app

import (
        "context"
        "fmt"
        "strings"

        "github.com/sufield/ephemos/internal/core/errors"
)

// YAML tag constants to avoid hardcoding.
const (
        ServiceYAMLTag           = "service"
        SPIFFEYAMLTag            = "spiffe"
        AuthorizedClientsYAMLTag = "authorized_clients"
        TrustedServersYAMLTag    = "trusted_servers"
        NameYAMLTag              = "name"
        DomainYAMLTag            = "domain"
        SocketPathYAMLTag        = "socket_path"
)

// Configuration represents the complete configuration for Ephemos services.
// It contains all necessary settings for service identity, SPIFFE integration,
// and authorization policies.
type Configuration struct {
        // Service contains the core service identification settings.
        // This is required and must include at least a service name.
        Service ServiceConfig `yaml:"service"`

        // SPIFFE contains optional SPIFFE/SPIRE integration settings.
        // If nil, default SPIFFE settings will be used.
        SPIFFE *SPIFFEConfig `yaml:"spiffe,omitempty"`

        // AuthorizedClients lists SPIFFE IDs that are allowed to connect to this service.
        // Each entry must be a valid SPIFFE ID (e.g., "spiffe://example.org/client-service").
        // Empty list means no client authorization is enforced.
        AuthorizedClients []string `yaml:"authorizedClients,omitempty"`

        // TrustedServers lists SPIFFE IDs of servers this client trusts to connect to.
        // Each entry must be a valid SPIFFE ID (e.g., "spiffe://example.org/server-service").
        // Empty list means all servers are trusted (not recommended for production).
        TrustedServers []string `yaml:"trustedServers,omitempty"`
}

// ServiceConfig contains the core service identification settings.
type ServiceConfig struct {
        // Name is the unique identifier for this service.
        // Required field, must be non-empty and contain only valid service name characters.
        // Used for SPIFFE ID generation and service discovery.
        Name string `yaml:"name"`

        // Domain is the trust domain for this service.
        // Optional field that defaults to the SPIRE trust domain if not specified.
        // Must be a valid domain name format if provided.
        Domain string `yaml:"domain,omitempty"`
}

// SPIFFEConfig contains SPIFFE/SPIRE integration settings.
type SPIFFEConfig struct {
        // SocketPath is the path to the SPIRE agent's Unix domain socket.
        // Must be an absolute path to a valid Unix socket file.
        // Common default: "/tmp/spire-agent/public/api.sock"
        SocketPath string `yaml:"socketPath"`
}

// Validate checks if the configuration is valid and returns any validation errors.
// This method ensures all required fields are present and properly formatted.
func (c *Configuration) Validate() error <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "configuration",
                        Value:   nil,
                        Message: "configuration cannot be nil",
                }
        }</span>

        // Validate service configuration
        <span class="cov0" title="0">if err := c.validateService(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid service configuration: %w", err)
        }</span>

        // Validate SPIFFE configuration if present
        <span class="cov0" title="0">if c.SPIFFE != nil </span><span class="cov0" title="0">{
                if err := c.validateSPIFFE(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid SPIFFE configuration: %w", err)
                }</span>
        }

        // Validate authorized clients
        <span class="cov0" title="0">if err := c.validateSPIFFEIDs(c.AuthorizedClients, "authorized_clients"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid authorized clients: %w", err)
        }</span>

        // Validate trusted servers
        <span class="cov0" title="0">if err := c.validateSPIFFEIDs(c.TrustedServers, "trusted_servers"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid trusted servers: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Configuration) validateService() error <span class="cov0" title="0">{
        if err := c.validateServiceName(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateServiceDomain(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

//nolint:cyclop // Validation function has inherent complexity from multiple checks
func (c *Configuration) validateServiceName() error <span class="cov0" title="0">{
        if strings.TrimSpace(c.Service.Name) == "" </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "service.name",
                        Value:   c.Service.Name,
                        Message: "service name is required and cannot be empty",
                }
        }</span>

        // Validate service name format (alphanumeric, hyphens, underscores)
        <span class="cov0" title="0">name := strings.TrimSpace(c.Service.Name)
        for _, char := range name </span><span class="cov0" title="0">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                        (char &gt;= '0' &amp;&amp; char &lt;= '9') || char == '-' || char == '_') </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   "service.name",
                                Value:   c.Service.Name,
                                Message: "service name must contain only alphanumeric characters, hyphens, and underscores",
                        }
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *Configuration) validateServiceDomain() error <span class="cov0" title="0">{
        // Validate domain format if provided
        if c.Service.Domain != "" </span><span class="cov0" title="0">{
                domain := strings.TrimSpace(c.Service.Domain)
                if domain == "" </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   "service.domain",
                                Value:   c.Service.Domain,
                                Message: "service domain cannot be whitespace only",
                        }
                }</span>
                // Basic domain validation - contains dots and valid characters
                <span class="cov0" title="0">if !strings.Contains(domain, ".") </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   "service.domain",
                                Value:   c.Service.Domain,
                                Message: "service domain must be a valid domain name",
                        }
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *Configuration) validateSPIFFE() error <span class="cov0" title="0">{
        if strings.TrimSpace(c.SPIFFE.SocketPath) == "" </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "spiffe.socket_path",
                        Value:   c.SPIFFE.SocketPath,
                        Message: "SPIFFE socket path is required when SPIFFE config is provided",
                }
        }</span>

        // Validate that socket path is absolute
        <span class="cov0" title="0">socketPath := strings.TrimSpace(c.SPIFFE.SocketPath)
        if !strings.HasPrefix(socketPath, "/") </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "spiffe.socket_path",
                        Value:   c.SPIFFE.SocketPath,
                        Message: "SPIFFE socket path must be an absolute path",
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Configuration) validateSPIFFEIDs(ids []string, fieldName string) error <span class="cov0" title="0">{
        for i, id := range ids </span><span class="cov0" title="0">{
                id = strings.TrimSpace(id)
                if id == "" </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   fmt.Sprintf("%s[%d]", fieldName, i),
                                Value:   ids[i],
                                Message: "SPIFFE ID cannot be empty or whitespace",
                        }
                }</span>

                // Validate SPIFFE ID format
                <span class="cov0" title="0">if !strings.HasPrefix(id, "spiffe://") </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   fmt.Sprintf("%s[%d]", fieldName, i),
                                Value:   ids[i],
                                Message: "SPIFFE ID must start with 'spiffe://' (e.g., 'spiffe://example.org/service')",
                        }
                }</span>

                // Basic structure validation - must have trust domain and path
                <span class="cov0" title="0">parts := strings.SplitN(id[9:], "/", 2) // Remove "spiffe://" prefix
                if len(parts) &lt; 2 || parts[0] == "" || parts[1] == "" </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   fmt.Sprintf("%s[%d]", fieldName, i),
                                Value:   ids[i],
                                Message: "SPIFFE ID must have format 'spiffe://trust-domain/path' (e.g., 'spiffe://example.org/service')",
                        }
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ConfigurationProvider defines the interface for loading and providing configurations.
type ConfigurationProvider interface {
        // LoadConfiguration loads configuration from the specified file path.
        // Returns an error if the path is empty or invalid, or if loading fails.
        LoadConfiguration(ctx context.Context, path string) (*Configuration, error)

        // GetDefaultConfiguration returns a configuration with sensible defaults.
        // The context can be used for cancellation during default value computation.
        GetDefaultConfiguration(ctx context.Context) *Configuration
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package app defines application errors and use cases
package app

import "fmt"

// DomainError represents errors in the domain logic.
type DomainError struct {
        Code    string
        Message string
        Err     error
}

func (e *DomainError) Error() string <span class="cov0" title="0">{
        if e.Err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.Err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

func (e *DomainError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// Common domain errors.
var (
        ErrInvalidServiceName = &amp;DomainError{
                Code:    "INVALID_SERVICE_NAME",
                Message: "service name is invalid",
        }

        ErrInvalidDomain = &amp;DomainError{
                Code:    "INVALID_DOMAIN",
                Message: "domain is invalid",
        }

        ErrMissingConfiguration = &amp;DomainError{
                Code:    "MISSING_CONFIGURATION",
                Message: "required configuration is missing",
        }

        ErrSPIFFERegistration = &amp;DomainError{
                Code:    "SPIFFE_REGISTRATION_FAILED",
                Message: "failed to register service with SPIFFE",
        }

        ErrInvalidSocketPath = &amp;DomainError{
                Code:    "INVALID_SOCKET_PATH",
                Message: "SPIFFE socket path is invalid",
        }

        ErrCertificateUnavailable = &amp;DomainError{
                Code:    "CERTIFICATE_UNAVAILABLE",
                Message: "certificate is not available",
        }

        ErrTrustBundleUnavailable = &amp;DomainError{
                Code:    "TRUST_BUNDLE_UNAVAILABLE",
                Message: "trust bundle is not available",
        }

        ErrConnectionFailed = &amp;DomainError{
                Code:    "CONNECTION_FAILED",
                Message: "failed to establish connection",
        }
)

// NewDomainError creates a new domain error with context.
func NewDomainError(base *DomainError, err error) error <span class="cov0" title="0">{
        return &amp;DomainError{
                Code:    base.Code,
                Message: base.Message,
                Err:     err,
        }
}</span>

// ValidationError represents input validation errors.
type ValidationError struct {
        Field   string
        Value   interface{}
        Message string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        valueStr := fmt.Sprintf("%v", e.Value)
        if e.Value == nil </span><span class="cov0" title="0">{
                valueStr = "&lt;nil&gt;"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("validation failed for field '%s' with value '%s': %s", e.Field, valueStr, e.Message)</span>
}

// NewValidationError creates a new validation error.
func NewValidationError(field, value, message string) *ValidationError <span class="cov0" title="0">{
        return &amp;ValidationError{
                Field:   field,
                Value:   value,
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package app provides application use cases and orchestration logic.
package app

import (
        "fmt"
        "sync"

        "github.com/sufield/ephemos/internal/domain"
)

// IdentityService manages service identities and provides authenticated transport.
// It handles certificate management, identity validation, and secure connection establishment.
// The service caches validated identities for performance and thread-safety.
type IdentityService struct {
        identityProvider  IdentityProvider
        transportProvider TransportProvider
        config            *Configuration
        cachedIdentity    *domain.ServiceIdentity
        mu                sync.RWMutex
}

// NewIdentityService creates a new IdentityService with the provided configuration.
// The configuration is validated and cached during initialization for better performance.
// Returns an error if the configuration is invalid.
func NewIdentityService(
        identityProvider IdentityProvider,
        transportProvider TransportProvider,
        config *Configuration,
) (*IdentityService, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{
                        Field:   "config",
                        Value:   nil,
                        Message: "configuration cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Create and validate identity during initialization
        <span class="cov0" title="0">identity := domain.NewServiceIdentity(config.Service.Name, config.Service.Domain)
        if err := identity.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid service identity: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;IdentityService{
                identityProvider:  identityProvider,
                transportProvider: transportProvider,
                config:            config,
                cachedIdentity:    identity,
        }, nil</span>
}

// CreateServerIdentity creates a server with identity-based authentication.
// Uses the cached identity and configuration to avoid redundant validation.
// Returns a configured server ready for service registration.
func (s *IdentityService) CreateServerIdentity() (Server, error) <span class="cov0" title="0">{
        s.mu.RLock()
        identity := s.cachedIdentity
        config := s.config
        s.mu.RUnlock()

        cert, err := s.getCertificate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get certificate for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">trustBundle, err := s.getTrustBundle()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trust bundle for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">policy := domain.NewAuthenticationPolicy(identity)
        for _, client := range config.AuthorizedClients </span><span class="cov0" title="0">{
                policy.AddAuthorizedClient(client)
        }</span>

        <span class="cov0" title="0">server, err := s.transportProvider.CreateServer(cert, trustBundle, policy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create server transport for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">return server, nil</span>
}

// CreateClientIdentity creates a client connection with identity-based authentication.
// Uses the cached identity and configuration to avoid redundant validation.
// Returns a client ready for establishing secure connections to servers.
func (s *IdentityService) CreateClientIdentity() (Client, error) <span class="cov0" title="0">{
        s.mu.RLock()
        identity := s.cachedIdentity
        config := s.config
        s.mu.RUnlock()

        cert, err := s.getCertificate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get certificate for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">trustBundle, err := s.getTrustBundle()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trust bundle for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">policy := domain.NewAuthenticationPolicy(identity)
        for _, server := range config.TrustedServers </span><span class="cov0" title="0">{
                policy.AddTrustedServer(server)
        }</span>

        <span class="cov0" title="0">client, err := s.transportProvider.CreateClient(cert, trustBundle, policy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create client transport for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// getCertificate retrieves the certificate from the identity provider.
func (s *IdentityService) getCertificate() (*domain.Certificate, error) <span class="cov0" title="0">{
        // In a pure domain service, we delegate to the port without exposing context
        // The adapter layer will handle context management
        cert, err := s.identityProvider.GetCertificate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get certificate: %w", err)
        }</span>
        <span class="cov0" title="0">return cert, nil</span>
}

// getTrustBundle retrieves the trust bundle from the identity provider.
func (s *IdentityService) getTrustBundle() (*domain.TrustBundle, error) <span class="cov0" title="0">{
        // In a pure domain service, we delegate to the port without exposing context
        // The adapter layer will handle context management
        bundle, err := s.identityProvider.GetTrustBundle()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trust bundle: %w", err)
        }</span>
        <span class="cov0" title="0">return bundle, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package cli provides command-line interface for Ephemos.
package cli

import (
        "context"
        "fmt"
        "log/slog"
        "os"

        "github.com/spf13/cobra"

        "github.com/sufield/ephemos/internal/adapters/primary/cli"
        "github.com/sufield/ephemos/internal/adapters/secondary/config"
        "github.com/sufield/ephemos/internal/core/ports"
)

//nolint:gochecknoglobals // CLI flags require global variables in Cobra
var (
        configFile    string
        serviceName   string
        serviceDomain string
        selector      string
)

var registerCmd = &amp;cobra.Command{ //nolint:gochecknoglobals // Cobra command pattern
        Use:   "register",
        Short: "Register a service with SPIRE",
        Long: `Register a service identity with SPIRE server.

You can either provide a config file or specify the service details directly.

Examples:
  # Using config file
  ephemos register --config service.yaml
  
  # Using command line arguments
  ephemos register --name echo-server --domain example.org
  ephemos register --name echo-server --domain example.org --selector unix:uid:1000`,
        RunE: runRegister,
}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits // Cobra requires init for flag setup
        registerCmd.Flags().StringVarP(&amp;configFile, "config", "c", "", "Path to configuration file")
        registerCmd.Flags().StringVarP(&amp;serviceName, "name", "n", "", "Service name")
        registerCmd.Flags().StringVarP(&amp;serviceDomain, "domain", "d", "example.org", "Service domain")
        registerCmd.Flags().StringVarP(&amp;selector, "selector", "s", "", "Custom selector (default: executable path)")
}</span>

func runRegister(_ *cobra.Command, _ []string) error <span class="cov0" title="0">{
        ctx := context.Background()

        cfg, err := loadConfiguration(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := performRegistration(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logRegistrationSuccess(cfg)
        return nil</span>
}

func loadConfiguration(ctx context.Context) (*ports.Configuration, error) <span class="cov0" title="0">{
        switch </span>{
        case configFile != "":<span class="cov0" title="0">
                return loadFromConfigFile(ctx)</span>
        case serviceName != "":<span class="cov0" title="0">
                return createTempConfigFromFlags()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("either --config or --name must be provided")</span>
        }
}

func loadFromConfigFile(ctx context.Context) (*ports.Configuration, error) <span class="cov0" title="0">{
        configProvider := config.NewFileProvider()
        cfg, err := configProvider.LoadConfiguration(ctx, configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        <span class="cov0" title="0">return cfg, nil</span>
}

func createTempConfigFromFlags() (*ports.Configuration, error) <span class="cov0" title="0">{
        cfg := &amp;ports.Configuration{
                Service: ports.ServiceConfig{
                        Name:   serviceName,
                        Domain: serviceDomain,
                },
        }

        tempFile, err := os.CreateTemp("", "ephemos-*.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp config: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := os.Remove(tempFile.Name()); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Failed to remove temp file", "file", tempFile.Name(), "error", err)
                }</span>
        }()

        <span class="cov0" title="0">configContent := fmt.Sprintf(`service:
  name: %s
  domain: %s
`, serviceName, serviceDomain)

        if _, err := tempFile.WriteString(configContent); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write temp config: %w", err)
        }</span>
        <span class="cov0" title="0">if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to close temp file: %w", err)
        }</span>

        <span class="cov0" title="0">configFile = tempFile.Name()
        return cfg, nil</span>
}

func performRegistration(ctx context.Context) error <span class="cov0" title="0">{
        registrarConfig := &amp;cli.RegistrarConfig{
                SPIRESocketPath: os.Getenv("SPIRE_SOCKET_PATH"),
                Logger:          slog.Default(),
        }

        configProvider := config.NewFileProvider()
        registrar := cli.NewRegistrar(configProvider, registrarConfig)

        if err := registrar.RegisterService(ctx, configFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("registration failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func logRegistrationSuccess(cfg *ports.Configuration) <span class="cov0" title="0">{
        slog.Info("Successfully registered service",
                "service", cfg.Service.Name,
                "domain", cfg.Service.Domain,
                "spiffe_id", fmt.Sprintf("spiffe://%s/%s", cfg.Service.Domain, cfg.Service.Name))

        if selector != "" </span><span class="cov0" title="0">{
                slog.Info("Service registered with selector", "selector", selector)
        }</span> else<span class="cov0" title="0"> {
                execPath, err := os.Executable()
                if err == nil </span><span class="cov0" title="0">{
                        slog.Info("Service registered with auto-determined selector", "selector", fmt.Sprintf("unix:path:%s", execPath))
                }</span> else<span class="cov0" title="0"> {
                        slog.Info("Service registered with auto-determined selector")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package cli

import (
        "fmt"

        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{ //nolint:gochecknoglobals // Cobra command pattern
        Use:   "ephemos",
        Short: "Identity-based authentication CLI for SPIFFE/SPIRE services",
        Long: `Identity-based authentication CLI for SPIFFE/SPIRE services.

Ephemos provides identity-based authentication for backend services using SPIFFE/SPIRE.
Use this CLI to register services, manage identities, and configure authentication policies.`,
}

// Execute runs the CLI.
func Execute() error <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute command: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits // Cobra requires init for command setup
        rootCmd.AddCommand(registerCmd)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package configurationprovider provides contract test suites for ConfigurationProvider implementations.
// These tests ensure that all ConfigurationProvider adapters behave consistently.
package configurationprovider

import (
        "context"
        "testing"

        "github.com/sufield/ephemos/internal/core/ports"
)

// Factory creates a new ConfigurationProvider implementation for testing.
type Factory func(t *testing.T) ports.ConfigurationProvider

// TestPaths provides test paths for configuration testing.
type TestPaths struct {
        ValidPath   string
        InvalidPath string
}

// Run executes the complete contract test suite against any ConfigurationProvider implementation.
func Run(t *testing.T, newImpl Factory, paths TestPaths) <span class="cov0" title="0">{
        t.Helper()
        ctx := t.Context()

        t.Run("load valid configuration", func(t *testing.T) </span><span class="cov0" title="0">{
                testLoadValidConfiguration(ctx, t, newImpl, paths.ValidPath)
        }</span>)

        <span class="cov0" title="0">t.Run("load invalid configuration", func(t *testing.T) </span><span class="cov0" title="0">{
                testLoadInvalidConfiguration(ctx, t, newImpl, paths.InvalidPath)
        }</span>)

        <span class="cov0" title="0">t.Run("get default configuration", func(t *testing.T) </span><span class="cov0" title="0">{
                testGetDefaultConfiguration(ctx, t, newImpl)
        }</span>)

        <span class="cov0" title="0">t.Run("empty path rejected", func(t *testing.T) </span><span class="cov0" title="0">{
                testEmptyPathRejected(ctx, t, newImpl)
        }</span>)

        <span class="cov0" title="0">t.Run("whitespace path rejected", func(t *testing.T) </span><span class="cov0" title="0">{
                testWhitespacePathRejected(ctx, t, newImpl)
        }</span>)

        <span class="cov0" title="0">t.Run("configuration validation edge cases", func(t *testing.T) </span><span class="cov0" title="0">{
                testConfigurationValidationEdgeCases(ctx, t, newImpl, paths)
        }</span>)
}

// testLoadValidConfiguration tests loading a valid configuration.
func testLoadValidConfiguration(ctx context.Context, t *testing.T, newImpl Factory, validPath string) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)

        config, err := provider.LoadConfiguration(ctx, validPath)
        // Contract: Either returns valid config or expected error
        if err != nil </span><span class="cov0" title="0">{
                t.Logf("LoadConfiguration returned error (may be expected): %v", err)
                return
        }</span>

        <span class="cov0" title="0">assertValidConfig(t, config)</span>
}

// testLoadInvalidConfiguration tests loading an invalid configuration.
func testLoadInvalidConfiguration(ctx context.Context, t *testing.T, newImpl Factory, invalidPath string) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)

        config, err := provider.LoadConfiguration(ctx, invalidPath)

        // Contract: Invalid config should return error
        if err == nil </span><span class="cov0" title="0">{
                t.Errorf("LoadConfiguration(%q) should return error", invalidPath)
        }</span>

        <span class="cov0" title="0">if config != nil </span><span class="cov0" title="0">{
                t.Error("LoadConfiguration should return nil config on error")
        }</span>
}

// testGetDefaultConfiguration tests getting the default configuration.
func testGetDefaultConfiguration(ctx context.Context, t *testing.T, newImpl Factory) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)

        config := provider.GetDefaultConfiguration(ctx)

        // Contract: May return nil if provider doesn't support defaults
        if config == nil </span><span class="cov0" title="0">{
                t.Log("GetDefaultConfiguration returned nil - provider may not support defaults")
                return
        }</span>

        <span class="cov0" title="0">assertValidConfig(t, config)</span>
}

// testEmptyPathRejected tests that empty paths are rejected.
func testEmptyPathRejected(ctx context.Context, t *testing.T, newImpl Factory) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)

        if _, err := provider.LoadConfiguration(ctx, ""); err == nil </span><span class="cov0" title="0">{
                t.Error("LoadConfiguration(\"\") should return error")
        }</span>
}

// testWhitespacePathRejected tests that whitespace paths are rejected.
func testWhitespacePathRejected(ctx context.Context, t *testing.T, newImpl Factory) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)

        if _, err := provider.LoadConfiguration(ctx, "   "); err == nil </span><span class="cov0" title="0">{
                t.Error("LoadConfiguration with whitespace should return error")
        }</span>
}

// testConfigurationValidationEdgeCases tests validation edge cases.
func testConfigurationValidationEdgeCases(ctx context.Context, t *testing.T, newImpl Factory, paths TestPaths) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)

        baseConfig := obtainBaseConfig(ctx, provider, paths)
        if baseConfig == nil </span><span class="cov0" title="0">{
                t.Skip("Cannot obtain config for validation testing")
        }</span>

        <span class="cov0" title="0">testInvalidModifications(t, baseConfig)</span>
}

// obtainBaseConfig attempts to get a valid configuration for testing.
func obtainBaseConfig(ctx context.Context, provider ports.ConfigurationProvider, paths TestPaths) *ports.Configuration <span class="cov0" title="0">{
        // Try valid path first
        if paths.ValidPath != "" </span><span class="cov0" title="0">{
                if config, err := provider.LoadConfiguration(ctx, paths.ValidPath); err == nil </span><span class="cov0" title="0">{
                        return config
                }</span>
        }

        // Fallback to default config
        <span class="cov0" title="0">return provider.GetDefaultConfiguration(ctx)</span>
}

// testInvalidModifications tests that invalid modifications are rejected.
func testInvalidModifications(t *testing.T, baseConfig *ports.Configuration) <span class="cov0" title="0">{
        t.Helper()
        testCases := []struct {
                name   string
                modify func(*ports.Configuration) *ports.Configuration
        }{
                {
                        name:   "empty service name",
                        modify: modifyServiceNameEmpty,
                },
                {
                        name:   "whitespace service name",
                        modify: modifyServiceNameWhitespace,
                },
        }

        for _, tc := range testCases </span><span class="cov0" title="0">{
                t.Run(tc.name, func(t *testing.T) </span><span class="cov0" title="0">{
                        invalidConfig := tc.modify(baseConfig)
                        if err := invalidConfig.Validate(); err == nil </span><span class="cov0" title="0">{
                                t.Errorf("Modified config should be invalid: %s", tc.name)
                        }</span>
                })
        }
}

// modifyServiceNameEmpty returns a config with empty service name.
func modifyServiceNameEmpty(c *ports.Configuration) *ports.Configuration <span class="cov0" title="0">{
        modified := *c
        modified.Service.Name = ""
        return &amp;modified
}</span>

// modifyServiceNameWhitespace returns a config with whitespace service name.
func modifyServiceNameWhitespace(c *ports.Configuration) *ports.Configuration <span class="cov0" title="0">{
        modified := *c
        modified.Service.Name = "   "
        return &amp;modified
}</span>

// assertValidConfig asserts that a configuration is valid.
func assertValidConfig(t *testing.T, config *ports.Configuration) <span class="cov0" title="0">{
        t.Helper()
        if config == nil </span><span class="cov0" title="0">{
                t.Fatal("Configuration should not be nil")
        }</span>

        // Validate basic config structure
        <span class="cov0" title="0">if config.Service.Name == "" </span><span class="cov0" title="0">{
                t.Error("Configuration.Service.Name should not be empty")
        }</span>

        // Config should be valid
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                t.Errorf("Configuration should be valid: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package identityprovider provides contract test suites for IdentityProvider implementations.
// These tests ensure that all IdentityProvider adapters behave consistently.
package identityprovider

import (
        "testing"

        "github.com/sufield/ephemos/internal/core/domain"
        "github.com/sufield/ephemos/internal/core/ports"
)

// Factory creates a new IdentityProvider implementation for testing.
type Factory func(t *testing.T) ports.IdentityProvider

// Run executes the complete contract test suite against any IdentityProvider implementation.
func Run(t *testing.T, newImpl Factory) <span class="cov0" title="0">{
        t.Helper()
        t.Run("get service identity", func(t *testing.T) </span><span class="cov0" title="0">{
                testGetServiceIdentity(t, newImpl)
        }</span>)

        <span class="cov0" title="0">t.Run("get certificate", func(t *testing.T) </span><span class="cov0" title="0">{
                testGetCertificate(t, newImpl)
        }</span>)

        <span class="cov0" title="0">t.Run("get trust bundle", func(t *testing.T) </span><span class="cov0" title="0">{
                testGetTrustBundle(t, newImpl)
        }</span>)

        <span class="cov0" title="0">t.Run("close is idempotent", func(t *testing.T) </span><span class="cov0" title="0">{
                testCloseIdempotent(t, newImpl)
        }</span>)

        <span class="cov0" title="0">t.Run("consistency across calls", func(t *testing.T) </span><span class="cov0" title="0">{
                testConsistencyAcrossCalls(t, newImpl)
        }</span>)
}

// testGetServiceIdentity tests getting service identity.
func testGetServiceIdentity(t *testing.T, newImpl Factory) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)
        defer closeProvider(t, provider)

        identity, err := provider.GetServiceIdentity()
        // Contract: Either returns valid identity or expected error
        if err != nil </span><span class="cov0" title="0">{
                t.Logf("GetServiceIdentity returned error (may be expected): %v", err)
                return
        }</span>

        <span class="cov0" title="0">assertValidIdentity(t, identity)</span>
}

// testGetCertificate tests getting certificate.
func testGetCertificate(t *testing.T, newImpl Factory) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)
        defer closeProvider(t, provider)

        cert, err := provider.GetCertificate()
        // Contract: Either returns valid certificate or expected error
        if err != nil </span><span class="cov0" title="0">{
                t.Logf("GetCertificate returned error (may be expected): %v", err)
                return
        }</span>

        <span class="cov0" title="0">assertValidCertificate(t, cert)</span>
}

// testGetTrustBundle tests getting trust bundle.
func testGetTrustBundle(t *testing.T, newImpl Factory) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)
        defer closeProvider(t, provider)

        bundle, err := provider.GetTrustBundle()
        // Contract: Either returns valid bundle or expected error
        if err != nil </span><span class="cov0" title="0">{
                t.Logf("GetTrustBundle returned error (may be expected): %v", err)
                return
        }</span>

        <span class="cov0" title="0">assertValidTrustBundle(t, bundle)</span>
}

// testCloseIdempotent tests that Close is idempotent.
func testCloseIdempotent(t *testing.T, newImpl Factory) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)

        // First close should succeed
        if err := provider.Close(); err != nil </span><span class="cov0" title="0">{
                t.Errorf("First Close() failed: %v", err)
        }</span>

        // Second close should be safe (idempotent)
        <span class="cov0" title="0">if err := provider.Close(); err != nil </span><span class="cov0" title="0">{
                t.Errorf("Second Close() failed (not idempotent): %v", err)
        }</span>
}

// testConsistencyAcrossCalls tests consistency across multiple calls.
func testConsistencyAcrossCalls(t *testing.T, newImpl Factory) <span class="cov0" title="0">{
        t.Helper()
        provider := newImpl(t)
        defer closeProvider(t, provider)

        identity1, err1 := provider.GetServiceIdentity()
        identity2, err2 := provider.GetServiceIdentity()

        // Both calls should have same error status
        if (err1 == nil) != (err2 == nil) </span><span class="cov0" title="0">{
                t.Error("GetServiceIdentity calls returned inconsistent error status")
                return
        }</span>

        // If both succeeded, results should be consistent
        <span class="cov0" title="0">if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                assertIdentitiesConsistent(t, identity1, identity2)
        }</span>
}

// closeProvider closes the provider with error logging.
func closeProvider(t *testing.T, provider ports.IdentityProvider) <span class="cov0" title="0">{
        t.Helper()
        if err := provider.Close(); err != nil </span><span class="cov0" title="0">{
                t.Logf("Failed to close provider: %v", err)
        }</span>
}

// assertValidIdentity asserts that a service identity is valid.
func assertValidIdentity(t *testing.T, identity *domain.ServiceIdentity) <span class="cov0" title="0">{
        t.Helper()
        if identity == nil </span><span class="cov0" title="0">{
                t.Fatal("GetServiceIdentity returned nil identity without error")
        }</span>

        <span class="cov0" title="0">if identity.Name == "" </span><span class="cov0" title="0">{
                t.Error("ServiceIdentity.Name should not be empty")
        }</span>

        <span class="cov0" title="0">if identity.Domain == "" </span><span class="cov0" title="0">{
                t.Error("ServiceIdentity.Domain should not be empty")
        }</span>

        <span class="cov0" title="0">if identity.URI == "" </span><span class="cov0" title="0">{
                t.Error("ServiceIdentity.URI should not be empty")
        }</span>

        <span class="cov0" title="0">if err := identity.Validate(); err != nil </span><span class="cov0" title="0">{
                t.Errorf("ServiceIdentity should be valid: %v", err)
        }</span>
}

// assertValidCertificate asserts that a certificate is valid.
func assertValidCertificate(t *testing.T, cert *domain.Certificate) <span class="cov0" title="0">{
        t.Helper()
        if cert == nil </span><span class="cov0" title="0">{
                t.Fatal("GetCertificate returned nil certificate without error")
        }</span>

        <span class="cov0" title="0">if cert.Cert == nil </span><span class="cov0" title="0">{
                t.Error("Certificate.Cert should not be nil")
        }</span>

        <span class="cov0" title="0">if cert.PrivateKey == nil </span><span class="cov0" title="0">{
                t.Error("Certificate.PrivateKey should not be nil")
        }</span>

        <span class="cov0" title="0">if len(cert.Chain) == 0 </span><span class="cov0" title="0">{
                t.Error("Certificate.Chain should not be empty")
        }</span>

        // Certificate chain consistency
        <span class="cov0" title="0">if cert.Cert != nil &amp;&amp; len(cert.Chain) &gt; 0 &amp;&amp; cert.Cert != cert.Chain[0] </span><span class="cov0" title="0">{
                t.Error("Certificate.Cert should be first in chain")
        }</span>
}

// assertValidTrustBundle asserts that a trust bundle is valid.
func assertValidTrustBundle(t *testing.T, bundle *domain.TrustBundle) <span class="cov0" title="0">{
        t.Helper()
        if bundle == nil </span><span class="cov0" title="0">{
                t.Fatal("GetTrustBundle returned nil bundle without error")
        }</span>

        <span class="cov0" title="0">if len(bundle.Certificates) == 0 </span><span class="cov0" title="0">{
                t.Error("TrustBundle.Certificates should not be empty")
        }</span>

        <span class="cov0" title="0">for i, cert := range bundle.Certificates </span><span class="cov0" title="0">{
                if cert == nil </span><span class="cov0" title="0">{
                        t.Errorf("TrustBundle.Certificates[%d] should not be nil", i)
                }</span>
        }
}

// assertIdentitiesConsistent asserts that two identities are consistent.
func assertIdentitiesConsistent(t *testing.T, identity1, identity2 *domain.ServiceIdentity) <span class="cov0" title="0">{
        t.Helper()
        if identity1.Name != identity2.Name </span><span class="cov0" title="0">{
                t.Error("GetServiceIdentity returned inconsistent Name")
        }</span>
        <span class="cov0" title="0">if identity1.Domain != identity2.Domain </span><span class="cov0" title="0">{
                t.Error("GetServiceIdentity returned inconsistent Domain")
        }</span>
        <span class="cov0" title="0">if identity1.URI != identity2.URI </span><span class="cov0" title="0">{
                t.Error("GetServiceIdentity returned inconsistent URI")
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package transportprovider provides contract test suites for TransportProvider implementations.
// These tests ensure that all TransportProvider adapters behave consistently.
package transportprovider

import (
        "testing"

        "github.com/sufield/ephemos/internal/core/domain"
        "github.com/sufield/ephemos/internal/core/ports"
)

// Factory creates a new TransportProvider implementation for testing.
type Factory func(t *testing.T) ports.TransportProvider

// TestDeps provides test dependencies needed by transport providers.
type TestDeps struct {
        Certificate *domain.Certificate
        TrustBundle *domain.TrustBundle
        AuthPolicy  *domain.AuthenticationPolicy
}

// Run executes the complete contract test suite against any TransportProvider implementation.
func Run(t *testing.T, newImpl Factory, deps TestDeps) <span class="cov0" title="0">{
        t.Helper()
        t.Run("create server", func(t *testing.T) </span><span class="cov0" title="0">{
                provider := newImpl(t)

                server, err := provider.CreateServer(deps.Certificate, deps.TrustBundle, deps.AuthPolicy)
                // Contract: Either returns functional server or expected error
                if err != nil </span><span class="cov0" title="0">{
                        t.Logf("CreateServer returned error (may be expected): %v", err)
                        return
                }</span>

                <span class="cov0" title="0">if server == nil </span><span class="cov0" title="0">{
                        t.Fatal("CreateServer returned nil server without error")
                }</span>

                // Server should handle Stop gracefully
                <span class="cov0" title="0">if err := server.Stop(); err != nil </span><span class="cov0" title="0">{
                        t.Logf("Server Stop returned: %v", err)
                }</span>
        })

        <span class="cov0" title="0">t.Run("create client", func(t *testing.T) </span><span class="cov0" title="0">{
                provider := newImpl(t)

                client, err := provider.CreateClient(deps.Certificate, deps.TrustBundle, deps.AuthPolicy)
                // Contract: Either returns functional client or expected error
                if err != nil </span><span class="cov0" title="0">{
                        t.Logf("CreateClient returned error (may be expected): %v", err)
                        return
                }</span>

                <span class="cov0" title="0">if client == nil </span><span class="cov0" title="0">{
                        t.Fatal("CreateClient returned nil client without error")
                }</span>

                // Client should handle Close gracefully
                <span class="cov0" title="0">if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        t.Logf("Client Close returned: %v", err)
                }</span>
        })

        <span class="cov0" title="0">t.Run("nil parameters rejected", func(t *testing.T) </span><span class="cov0" title="0">{
                provider := newImpl(t)

                // CreateServer with nil parameters should error
                if _, err := provider.CreateServer(nil, nil, nil); err == nil </span><span class="cov0" title="0">{
                        t.Error("CreateServer(nil, nil, nil) should return error")
                }</span>

                // CreateClient with nil parameters should error
                <span class="cov0" title="0">if _, err := provider.CreateClient(nil, nil, nil); err == nil </span><span class="cov0" title="0">{
                        t.Error("CreateClient(nil, nil, nil) should return error")
                }</span>
        })
}

// ServerFactory creates a Server implementation for testing.
type ServerFactory func(t *testing.T) ports.Server

// RunServerSuite tests Server interface compliance.
func RunServerSuite(t *testing.T, newServer ServerFactory) <span class="cov0" title="0">{
        t.Helper()
        t.Run("register service validation", func(t *testing.T) </span><span class="cov0" title="0">{
                server := newServer(t)
                defer func() </span><span class="cov0" title="0">{
                        if err := server.Stop(); err != nil </span><span class="cov0" title="0">{
                                t.Logf("Failed to stop server: %v", err)
                        }</span>
                }()

                // RegisterService with nil should error
                <span class="cov0" title="0">if err := server.RegisterService(nil); err == nil </span><span class="cov0" title="0">{
                        t.Error("RegisterService(nil) should return error")
                }</span>
        })

        <span class="cov0" title="0">t.Run("start validation", func(t *testing.T) </span><span class="cov0" title="0">{
                server := newServer(t)
                defer func() </span><span class="cov0" title="0">{
                        if err := server.Stop(); err != nil </span><span class="cov0" title="0">{
                                t.Logf("Failed to stop server: %v", err)
                        }</span>
                }()

                // Start with nil listener should error
                <span class="cov0" title="0">if err := server.Start(nil); err == nil </span><span class="cov0" title="0">{
                        t.Error("Start(nil) should return error")
                }</span>
        })

        <span class="cov0" title="0">t.Run("stop is idempotent", func(t *testing.T) </span><span class="cov0" title="0">{
                server := newServer(t)

                // First stop
                if err := server.Stop(); err != nil </span><span class="cov0" title="0">{
                        t.Logf("First Stop() returned: %v", err)
                }</span>

                // Second stop should be safe
                <span class="cov0" title="0">if err := server.Stop(); err != nil </span><span class="cov0" title="0">{
                        t.Logf("Second Stop() returned: %v", err)
                }</span>
        })
}

// ClientFactory creates a Client implementation for testing.
type ClientFactory func(t *testing.T) ports.Client

// RunClientSuite tests Client interface compliance.
func RunClientSuite(t *testing.T, newClient ClientFactory) <span class="cov0" title="0">{
        t.Helper()
        t.Run("connect validation", func(t *testing.T) </span><span class="cov0" title="0">{
                client := newClient(t)
                defer func() </span><span class="cov0" title="0">{
                        if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                                t.Logf("Failed to close client: %v", err)
                        }</span>
                }()

                // Connect with empty parameters should error
                <span class="cov0" title="0">if _, err := client.Connect("", ""); err == nil </span><span class="cov0" title="0">{
                        t.Error("Connect(\"\", \"\") should return error")
                }</span>
        })

        <span class="cov0" title="0">t.Run("close is idempotent", func(t *testing.T) </span><span class="cov0" title="0">{
                client := newClient(t)

                // First close
                if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        t.Logf("First Close() returned: %v", err)
                }</span>

                // Second close should be safe
                <span class="cov0" title="0">if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        t.Logf("Second Close() returned: %v", err)
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package domain handles service identity and authentication policies.
package domain

import (
        "crypto/x509"
        "fmt"
)

// ServiceIdentity represents a SPIFFE service identity with name, domain, and URI.
type ServiceIdentity struct {
        Name   string
        Domain string
        URI    string
}

// NewServiceIdentity creates a new ServiceIdentity with the given name and domain.
func NewServiceIdentity(name, domain string) *ServiceIdentity <span class="cov4" title="20">{
        return &amp;ServiceIdentity{
                Name:   name,
                Domain: domain,
                URI:    fmt.Sprintf("spiffe://%s/%s", domain, name),
        }
}</span>

// Validate checks the identity.
func (s *ServiceIdentity) Validate() error <span class="cov10" title="1004">{
        if s.Name == "" </span><span class="cov1" title="2">{
                return fmt.Errorf("service name cannot be empty")
        }</span>
        <span class="cov9" title="1002">if s.Domain == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("domain cannot be empty")
        }</span>
        <span class="cov9" title="1001">return nil</span>
}

// Certificate holds cert data.
type Certificate struct {
        Cert       *x509.Certificate
        PrivateKey interface{}
        Chain      []*x509.Certificate
}

// TrustBundle holds trust data.
type TrustBundle struct {
        Certificates []*x509.Certificate
}

// AuthenticationPolicy defines auth rules.
type AuthenticationPolicy struct {
        ServiceIdentity   *ServiceIdentity
        AuthorizedClients []string
        TrustedServers    []string
}

// NewAuthenticationPolicy creates a policy.
func NewAuthenticationPolicy(identity *ServiceIdentity) *AuthenticationPolicy <span class="cov0" title="0">{
        return &amp;AuthenticationPolicy{
                ServiceIdentity:   identity,
                AuthorizedClients: []string{},
                TrustedServers:    []string{},
        }
}</span>

// AddAuthorizedClient adds a client.
func (p *AuthenticationPolicy) AddAuthorizedClient(clientName string) <span class="cov0" title="0">{
        p.AuthorizedClients = append(p.AuthorizedClients, clientName)
}</span>

// AddTrustedServer adds a server.
func (p *AuthenticationPolicy) AddTrustedServer(serverName string) <span class="cov0" title="0">{
        p.TrustedServers = append(p.TrustedServers, serverName)
}</span>

// IsClientAuthorized checks client.
func (p *AuthenticationPolicy) IsClientAuthorized(clientName string) bool <span class="cov0" title="0">{
        if len(p.AuthorizedClients) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, authorized := range p.AuthorizedClients </span><span class="cov0" title="0">{
                if authorized == clientName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsServerTrusted checks server.
func (p *AuthenticationPolicy) IsServerTrusted(serverName string) bool <span class="cov0" title="0">{
        if len(p.TrustedServers) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, trusted := range p.TrustedServers </span><span class="cov0" title="0">{
                if trusted == serverName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package errors defines custom error types for the Ephemos library
package errors

import "fmt"

// DomainError represents errors in the domain logic.
type DomainError struct {
        Code    string
        Message string
        Err     error
}

func (e *DomainError) Error() string <span class="cov9" title="7">{
        if e.Err != nil </span><span class="cov5" title="3">{
                return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.Err)
        }</span>
        <span class="cov7" title="4">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

func (e *DomainError) Unwrap() error <span class="cov10" title="8">{
        return e.Err
}</span>

// Common domain errors.
var (
        ErrInvalidServiceName = &amp;DomainError{
                Code:    "INVALID_SERVICE_NAME",
                Message: "service name is invalid",
        }

        ErrInvalidDomain = &amp;DomainError{
                Code:    "INVALID_DOMAIN",
                Message: "domain is invalid",
        }

        ErrMissingConfiguration = &amp;DomainError{
                Code:    "MISSING_CONFIGURATION",
                Message: "required configuration is missing",
        }

        ErrSPIFFERegistration = &amp;DomainError{
                Code:    "SPIFFE_REGISTRATION_FAILED",
                Message: "failed to register service with SPIFFE",
        }

        ErrInvalidSocketPath = &amp;DomainError{
                Code:    "INVALID_SOCKET_PATH",
                Message: "SPIFFE socket path is invalid",
        }

        ErrCertificateUnavailable = &amp;DomainError{
                Code:    "CERTIFICATE_UNAVAILABLE",
                Message: "certificate is not available",
        }

        ErrTrustBundleUnavailable = &amp;DomainError{
                Code:    "TRUST_BUNDLE_UNAVAILABLE",
                Message: "trust bundle is not available",
        }

        ErrConnectionFailed = &amp;DomainError{
                Code:    "CONNECTION_FAILED",
                Message: "failed to establish connection",
        }
)

// NewDomainError creates a new domain error with context.
func NewDomainError(base *DomainError, err error) error <span class="cov8" title="6">{
        return &amp;DomainError{
                Code:    base.Code,
                Message: base.Message,
                Err:     err,
        }
}</span>

// ValidationError represents input validation errors.
type ValidationError struct {
        Field   string
        Value   interface{}
        Message string
}

func (e *ValidationError) Error() string <span class="cov7" title="5">{
        valueStr := fmt.Sprintf("%v", e.Value)
        if e.Value == nil </span><span class="cov1" title="1">{
                valueStr = "&lt;nil&gt;"
        }</span>
        <span class="cov7" title="5">return fmt.Sprintf("validation failed for field '%s' with value '%s': %s", e.Field, valueStr, e.Message)</span>
}

// NewValidationError creates a new validation error.
func NewValidationError(field, value, message string) *ValidationError <span class="cov5" title="3">{
        return &amp;ValidationError{
                Field:   field,
                Value:   value,
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package ports defines interfaces for core services and domain boundaries.
package ports

import (
        "context"
        "fmt"
        "strings"

        "github.com/sufield/ephemos/internal/core/errors"
)

// YAML tag constants to avoid hardcoding.
const (
        ServiceYAMLTag           = "service"
        SPIFFEYAMLTag            = "spiffe"
        AuthorizedClientsYAMLTag = "authorized_clients"
        TrustedServersYAMLTag    = "trusted_servers"
        NameYAMLTag              = "name"
        DomainYAMLTag            = "domain"
        SocketPathYAMLTag        = "socket_path"
)

// Configuration represents the complete configuration for Ephemos services.
// It contains all necessary settings for service identity, SPIFFE integration,
// and authorization policies.
type Configuration struct {
        // Service contains the core service identification settings.
        // This is required and must include at least a service name.
        Service ServiceConfig `yaml:"service"`

        // SPIFFE contains optional SPIFFE/SPIRE integration settings.
        // If nil, default SPIFFE settings will be used.
        SPIFFE *SPIFFEConfig `yaml:"spiffe,omitempty"`

        // AuthorizedClients lists SPIFFE IDs that are allowed to connect to this service.
        // Each entry must be a valid SPIFFE ID (e.g., "spiffe://example.org/client-service").
        // Empty list means no client authorization is enforced.
        AuthorizedClients []string `yaml:"authorizedClients,omitempty"`

        // TrustedServers lists SPIFFE IDs of servers this client trusts to connect to.
        // Each entry must be a valid SPIFFE ID (e.g., "spiffe://example.org/server-service").
        // Empty list means all servers are trusted (not recommended for production).
        TrustedServers []string `yaml:"trustedServers,omitempty"`
}

// ServiceConfig contains the core service identification settings.
type ServiceConfig struct {
        // Name is the unique identifier for this service.
        // Required field, must be non-empty and contain only valid service name characters.
        // Used for SPIFFE ID generation and service discovery.
        Name string `yaml:"name"`

        // Domain is the trust domain for this service.
        // Optional field that defaults to the SPIRE trust domain if not specified.
        // Must be a valid domain name format if provided.
        Domain string `yaml:"domain,omitempty"`
}

// SPIFFEConfig contains SPIFFE/SPIRE integration settings.
type SPIFFEConfig struct {
        // SocketPath is the path to the SPIRE agent's Unix domain socket.
        // Must be an absolute path to a valid Unix socket file.
        // Common default: "/tmp/spire-agent/public/api.sock"
        SocketPath string `yaml:"socketPath"`
}

// Validate checks if the configuration is valid and returns any validation errors.
// This method ensures all required fields are present and properly formatted.
func (c *Configuration) Validate() error <span class="cov4" title="19">{
        if c == nil </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "configuration",
                        Value:   nil,
                        Message: "configuration cannot be nil",
                }
        }</span>

        // Validate service configuration
        <span class="cov4" title="19">if err := c.validateService(); err != nil </span><span class="cov3" title="7">{
                return fmt.Errorf("invalid service configuration: %w", err)
        }</span>

        // Validate SPIFFE configuration if present
        <span class="cov4" title="12">if c.SPIFFE != nil </span><span class="cov3" title="9">{
                if err := c.validateSPIFFE(); err != nil </span><span class="cov1" title="2">{
                        return fmt.Errorf("invalid SPIFFE configuration: %w", err)
                }</span>
        }

        // Validate authorized clients
        <span class="cov3" title="10">if err := c.validateSPIFFEIDs(c.AuthorizedClients, "authorized_clients"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid authorized clients: %w", err)
        }</span>

        // Validate trusted servers
        <span class="cov3" title="10">if err := c.validateSPIFFEIDs(c.TrustedServers, "trusted_servers"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid trusted servers: %w", err)
        }</span>

        <span class="cov3" title="10">return nil</span>
}

func (c *Configuration) validateService() error <span class="cov4" title="19">{
        if err := c.validateServiceName(); err != nil </span><span class="cov3" title="6">{
                return err
        }</span>

        <span class="cov4" title="13">if err := c.validateServiceDomain(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="12">return nil</span>
}

//nolint:cyclop // Validation function has inherent complexity from multiple checks
func (c *Configuration) validateServiceName() error <span class="cov4" title="19">{
        if strings.TrimSpace(c.Service.Name) == "" </span><span class="cov3" title="5">{
                return &amp;errors.ValidationError{
                        Field:   "service.name",
                        Value:   c.Service.Name,
                        Message: "service name is required and cannot be empty",
                }
        }</span>

        // Validate service name format (alphanumeric, hyphens, underscores)
        <span class="cov4" title="14">name := strings.TrimSpace(c.Service.Name)
        for _, char := range name </span><span class="cov10" title="1145">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                        (char &gt;= '0' &amp;&amp; char &lt;= '9') || char == '-' || char == '_') </span><span class="cov1" title="1">{
                        return &amp;errors.ValidationError{
                                Field:   "service.name",
                                Value:   c.Service.Name,
                                Message: "service name must contain only alphanumeric characters, hyphens, and underscores",
                        }
                }</span>
        }

        <span class="cov4" title="13">return nil</span>
}

func (c *Configuration) validateServiceDomain() error <span class="cov4" title="13">{
        // Validate domain format if provided
        if c.Service.Domain != "" </span><span class="cov3" title="8">{
                domain := strings.TrimSpace(c.Service.Domain)
                if domain == "" </span><span class="cov1" title="1">{
                        return &amp;errors.ValidationError{
                                Field:   "service.domain",
                                Value:   c.Service.Domain,
                                Message: "service domain cannot be whitespace only",
                        }
                }</span>
                // Basic domain validation - contains dots and valid characters
                <span class="cov3" title="7">if !strings.Contains(domain, ".") </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   "service.domain",
                                Value:   c.Service.Domain,
                                Message: "service domain must be a valid domain name",
                        }
                }</span>
        }

        <span class="cov4" title="12">return nil</span>
}

func (c *Configuration) validateSPIFFE() error <span class="cov3" title="9">{
        if strings.TrimSpace(c.SPIFFE.SocketPath) == "" </span><span class="cov1" title="2">{
                return &amp;errors.ValidationError{
                        Field:   "spiffe.socket_path",
                        Value:   c.SPIFFE.SocketPath,
                        Message: "SPIFFE socket path is required when SPIFFE config is provided",
                }
        }</span>

        // Validate that socket path is absolute
        <span class="cov3" title="7">socketPath := strings.TrimSpace(c.SPIFFE.SocketPath)
        if !strings.HasPrefix(socketPath, "/") </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "spiffe.socket_path",
                        Value:   c.SPIFFE.SocketPath,
                        Message: "SPIFFE socket path must be an absolute path",
                }
        }</span>

        <span class="cov3" title="7">return nil</span>
}

func (c *Configuration) validateSPIFFEIDs(ids []string, fieldName string) error <span class="cov4" title="20">{
        for i, id := range ids </span><span class="cov0" title="0">{
                id = strings.TrimSpace(id)
                if id == "" </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   fmt.Sprintf("%s[%d]", fieldName, i),
                                Value:   ids[i],
                                Message: "SPIFFE ID cannot be empty or whitespace",
                        }
                }</span>

                // Validate SPIFFE ID format
                <span class="cov0" title="0">if !strings.HasPrefix(id, "spiffe://") </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   fmt.Sprintf("%s[%d]", fieldName, i),
                                Value:   ids[i],
                                Message: "SPIFFE ID must start with 'spiffe://' (e.g., 'spiffe://example.org/service')",
                        }
                }</span>

                // Basic structure validation - must have trust domain and path
                <span class="cov0" title="0">parts := strings.SplitN(id[9:], "/", 2) // Remove "spiffe://" prefix
                if len(parts) &lt; 2 || parts[0] == "" || parts[1] == "" </span><span class="cov0" title="0">{
                        return &amp;errors.ValidationError{
                                Field:   fmt.Sprintf("%s[%d]", fieldName, i),
                                Value:   ids[i],
                                Message: "SPIFFE ID must have format 'spiffe://trust-domain/path' (e.g., 'spiffe://example.org/service')",
                        }
                }</span>
        }

        <span class="cov4" title="20">return nil</span>
}

// ConfigurationProvider defines the interface for loading and providing configurations.
type ConfigurationProvider interface {
        // LoadConfiguration loads configuration from the specified file path.
        // Returns an error if the path is empty or invalid, or if loading fails.
        LoadConfiguration(ctx context.Context, path string) (*Configuration, error)

        // GetDefaultConfiguration returns a configuration with sensible defaults.
        // The context can be used for cancellation during default value computation.
        GetDefaultConfiguration(ctx context.Context) *Configuration
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package services provides core business logic services.
package services

import (
        "fmt"
        "sync"

        "github.com/sufield/ephemos/internal/core/domain"
        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
)

// IdentityService manages service identities and provides authenticated transport.
// It handles certificate management, identity validation, and secure connection establishment.
// The service caches validated identities for performance and thread-safety.
type IdentityService struct {
        identityProvider  ports.IdentityProvider
        transportProvider ports.TransportProvider
        config            *ports.Configuration
        cachedIdentity    *domain.ServiceIdentity
        mu                sync.RWMutex
}

// NewIdentityService creates a new IdentityService with the provided configuration.
// The configuration is validated and cached during initialization for better performance.
// Returns an error if the configuration is invalid.
func NewIdentityService(
        identityProvider ports.IdentityProvider,
        transportProvider ports.TransportProvider,
        config *ports.Configuration,
) (*IdentityService, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "config",
                        Value:   nil,
                        Message: "configuration cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Create and validate identity during initialization
        <span class="cov0" title="0">identity := domain.NewServiceIdentity(config.Service.Name, config.Service.Domain)
        if err := identity.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid service identity: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;IdentityService{
                identityProvider:  identityProvider,
                transportProvider: transportProvider,
                config:            config,
                cachedIdentity:    identity,
        }, nil</span>
}

// CreateServerIdentity creates a server with identity-based authentication.
// Uses the cached identity and configuration to avoid redundant validation.
// Returns a configured server ready for service registration.
func (s *IdentityService) CreateServerIdentity() (ports.Server, error) <span class="cov0" title="0">{
        s.mu.RLock()
        identity := s.cachedIdentity
        config := s.config
        s.mu.RUnlock()

        cert, err := s.getCertificate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get certificate for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">trustBundle, err := s.getTrustBundle()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trust bundle for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">policy := domain.NewAuthenticationPolicy(identity)
        for _, client := range config.AuthorizedClients </span><span class="cov0" title="0">{
                policy.AddAuthorizedClient(client)
        }</span>

        <span class="cov0" title="0">server, err := s.transportProvider.CreateServer(cert, trustBundle, policy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create server transport for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">return server, nil</span>
}

// CreateClientIdentity creates a client connection with identity-based authentication.
// Uses the cached identity and configuration to avoid redundant validation.
// Returns a client ready for establishing secure connections to servers.
func (s *IdentityService) CreateClientIdentity() (ports.Client, error) <span class="cov0" title="0">{
        s.mu.RLock()
        identity := s.cachedIdentity
        config := s.config
        s.mu.RUnlock()

        cert, err := s.getCertificate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get certificate for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">trustBundle, err := s.getTrustBundle()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trust bundle for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">policy := domain.NewAuthenticationPolicy(identity)
        for _, server := range config.TrustedServers </span><span class="cov0" title="0">{
                policy.AddTrustedServer(server)
        }</span>

        <span class="cov0" title="0">client, err := s.transportProvider.CreateClient(cert, trustBundle, policy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create client transport for service %s: %w", identity.Name, err)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// getCertificate retrieves the certificate from the identity provider.
func (s *IdentityService) getCertificate() (*domain.Certificate, error) <span class="cov0" title="0">{
        // In a pure domain service, we delegate to the port without exposing context
        // The adapter layer will handle context management
        cert, err := s.identityProvider.GetCertificate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get certificate: %w", err)
        }</span>
        <span class="cov0" title="0">return cert, nil</span>
}

// getTrustBundle retrieves the trust bundle from the identity provider.
func (s *IdentityService) getTrustBundle() (*domain.TrustBundle, error) <span class="cov0" title="0">{
        // In a pure domain service, we delegate to the port without exposing context
        // The adapter layer will handle context management
        bundle, err := s.identityProvider.GetTrustBundle()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trust bundle: %w", err)
        }</span>
        <span class="cov0" title="0">return bundle, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package domain handles service identity and authentication policies.
package domain

import (
        "crypto/x509"
        "fmt"
)

// ServiceIdentity represents a SPIFFE service identity with name, domain, and URI.
type ServiceIdentity struct {
        Name   string
        Domain string
        URI    string
}

// NewServiceIdentity creates a new ServiceIdentity with the given name and domain.
func NewServiceIdentity(name, domain string) *ServiceIdentity <span class="cov0" title="0">{
        return &amp;ServiceIdentity{
                Name:   name,
                Domain: domain,
                URI:    fmt.Sprintf("spiffe://%s/%s", domain, name),
        }
}</span>

// Validate checks the identity.
func (s *ServiceIdentity) Validate() error <span class="cov0" title="0">{
        if s.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service name cannot be empty")
        }</span>
        <span class="cov0" title="0">if s.Domain == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("domain cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Certificate holds cert data.
type Certificate struct {
        Cert       *x509.Certificate
        PrivateKey interface{}
        Chain      []*x509.Certificate
}

// TrustBundle holds trust data.
type TrustBundle struct {
        Certificates []*x509.Certificate
}

// AuthenticationPolicy defines auth rules.
type AuthenticationPolicy struct {
        ServiceIdentity   *ServiceIdentity
        AuthorizedClients []string
        TrustedServers    []string
}

// NewAuthenticationPolicy creates a policy.
func NewAuthenticationPolicy(identity *ServiceIdentity) *AuthenticationPolicy <span class="cov0" title="0">{
        return &amp;AuthenticationPolicy{
                ServiceIdentity:   identity,
                AuthorizedClients: []string{},
                TrustedServers:    []string{},
        }
}</span>

// AddAuthorizedClient adds a client.
func (p *AuthenticationPolicy) AddAuthorizedClient(clientName string) <span class="cov0" title="0">{
        p.AuthorizedClients = append(p.AuthorizedClients, clientName)
}</span>

// AddTrustedServer adds a server.
func (p *AuthenticationPolicy) AddTrustedServer(serverName string) <span class="cov0" title="0">{
        p.TrustedServers = append(p.TrustedServers, serverName)
}</span>

// IsClientAuthorized checks client.
func (p *AuthenticationPolicy) IsClientAuthorized(clientName string) bool <span class="cov0" title="0">{
        if len(p.AuthorizedClients) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, authorized := range p.AuthorizedClients </span><span class="cov0" title="0">{
                if authorized == clientName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsServerTrusted checks server.
func (p *AuthenticationPolicy) IsServerTrusted(serverName string) bool <span class="cov0" title="0">{
        if len(p.TrustedServers) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, trusted := range p.TrustedServers </span><span class="cov0" title="0">{
                if trusted == serverName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package cli provides command-line interface for Ephemos.
package cli

import (
        "context"
        "fmt"
        "log/slog"
        "os"

        "github.com/spf13/cobra"

        "github.com/sufield/ephemos/internal/adapters/primary/cli"
        "github.com/sufield/ephemos/internal/adapters/secondary/config"
        "github.com/sufield/ephemos/internal/core/ports"
)

//nolint:gochecknoglobals // CLI flags require global variables in Cobra
var (
        configFile    string
        serviceName   string
        serviceDomain string
        selector      string
)

var registerCmd = &amp;cobra.Command{ //nolint:gochecknoglobals // Cobra command pattern
        Use:   "register",
        Short: "Register a service with SPIRE",
        Long: `Register a service identity with SPIRE server.

You can either provide a config file or specify the service details directly.

Examples:
  # Using config file
  ephemos register --config service.yaml
  
  # Using command line arguments
  ephemos register --name echo-server --domain example.org
  ephemos register --name echo-server --domain example.org --selector unix:uid:1000`,
        RunE: runRegister,
}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits // Cobra requires init for flag setup
        registerCmd.Flags().StringVarP(&amp;configFile, "config", "c", "", "Path to configuration file")
        registerCmd.Flags().StringVarP(&amp;serviceName, "name", "n", "", "Service name")
        registerCmd.Flags().StringVarP(&amp;serviceDomain, "domain", "d", "example.org", "Service domain")
        registerCmd.Flags().StringVarP(&amp;selector, "selector", "s", "", "Custom selector (default: executable path)")
}</span>

func runRegister(_ *cobra.Command, _ []string) error <span class="cov0" title="0">{
        ctx := context.Background()

        cfg, err := loadConfiguration(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := performRegistration(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logRegistrationSuccess(cfg)
        return nil</span>
}

func loadConfiguration(ctx context.Context) (*ports.Configuration, error) <span class="cov0" title="0">{
        switch </span>{
        case configFile != "":<span class="cov0" title="0">
                return loadFromConfigFile(ctx)</span>
        case serviceName != "":<span class="cov0" title="0">
                return createTempConfigFromFlags()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("either --config or --name must be provided")</span>
        }
}

func loadFromConfigFile(ctx context.Context) (*ports.Configuration, error) <span class="cov0" title="0">{
        configProvider := config.NewFileProvider()
        cfg, err := configProvider.LoadConfiguration(ctx, configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        <span class="cov0" title="0">return cfg, nil</span>
}

func createTempConfigFromFlags() (*ports.Configuration, error) <span class="cov0" title="0">{
        cfg := &amp;ports.Configuration{
                Service: ports.ServiceConfig{
                        Name:   serviceName,
                        Domain: serviceDomain,
                },
        }

        tempFile, err := os.CreateTemp("", "ephemos-*.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp config: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := os.Remove(tempFile.Name()); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Failed to remove temp file", "file", tempFile.Name(), "error", err)
                }</span>
        }()

        <span class="cov0" title="0">configContent := fmt.Sprintf(`service:
  name: %s
  domain: %s
`, serviceName, serviceDomain)

        if _, err := tempFile.WriteString(configContent); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write temp config: %w", err)
        }</span>
        <span class="cov0" title="0">if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to close temp file: %w", err)
        }</span>

        <span class="cov0" title="0">configFile = tempFile.Name()
        return cfg, nil</span>
}

func performRegistration(ctx context.Context) error <span class="cov0" title="0">{
        registrarConfig := &amp;cli.RegistrarConfig{
                SPIRESocketPath: os.Getenv("SPIRE_SOCKET_PATH"),
                Logger:          slog.Default(),
        }

        configProvider := config.NewFileProvider()
        registrar := cli.NewRegistrar(configProvider, registrarConfig)

        if err := registrar.RegisterService(ctx, configFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("registration failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func logRegistrationSuccess(cfg *ports.Configuration) <span class="cov0" title="0">{
        slog.Info("Successfully registered service",
                "service", cfg.Service.Name,
                "domain", cfg.Service.Domain,
                "spiffe_id", fmt.Sprintf("spiffe://%s/%s", cfg.Service.Domain, cfg.Service.Name))

        if selector != "" </span><span class="cov0" title="0">{
                slog.Info("Service registered with selector", "selector", selector)
        }</span> else<span class="cov0" title="0"> {
                execPath, err := os.Executable()
                if err == nil </span><span class="cov0" title="0">{
                        slog.Info("Service registered with auto-determined selector", "selector", fmt.Sprintf("unix:path:%s", execPath))
                }</span> else<span class="cov0" title="0"> {
                        slog.Info("Service registered with auto-determined selector")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package cli provides command-line interface implementations for Ephemos
package cli

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/spiffe/go-spiffe/v2/spiffeid"

        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
)

// RegistrarConfig holds configuration for the Registrar.
type RegistrarConfig struct {
        SPIRESocketPath string
        SPIREServerPath string // Path to spire-server binary
        Logger          *slog.Logger
}

// Registrar handles service registration with SPIRE.
type Registrar struct {
        configProvider  ports.ConfigurationProvider
        spireSocketPath string
        spireServerPath string
        logger          *slog.Logger
}

// isValidPath validates that a path is safe to use.
func isValidPath(path string) bool <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">cleanPath := filepath.Clean(path)
        // Prevent path traversal
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return false
        }</span>
        // Ensure it's within allowed paths for SPIRE
        <span class="cov0" title="0">allowedPaths := []string{"/usr/bin/", "/usr/local/bin/", "/opt/spire/bin/", "./bin/"}
        for _, allowed := range allowedPaths </span><span class="cov0" title="0">{
                if strings.HasPrefix(cleanPath, allowed) || cleanPath == "spire-server" || cleanPath == "echo" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isValidSocketPath validates that a socket path is safe to use.
func isValidSocketPath(path string) bool <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">cleanPath := filepath.Clean(path)
        // Prevent path traversal
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return false
        }</span>
        // Must be a socket file (typically .sock extension or in /tmp)
        <span class="cov0" title="0">return strings.HasSuffix(cleanPath, ".sock") || strings.HasPrefix(cleanPath, "/tmp/") || strings.HasPrefix(cleanPath, "/var/run/")</span>
}

// isValidSelector validates that a selector is in the correct format.
func isValidSelector(selector string) bool <span class="cov0" title="0">{
        if selector == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        // Basic validation - selectors should be in format "type:key:value"
        <span class="cov0" title="0">parts := strings.Split(selector, ":")
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        // First part should be a known selector type
        <span class="cov0" title="0">validTypes := []string{"unix", "k8s", "docker"}
        for _, validType := range validTypes </span><span class="cov0" title="0">{
                if parts[0] == validType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// NewRegistrar creates a new Registrar with proper dependency injection.
func NewRegistrar(
        configProvider ports.ConfigurationProvider,
        config *RegistrarConfig,
) *Registrar <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;RegistrarConfig{}
        }</span>

        <span class="cov0" title="0">if config.SPIRESocketPath == "" </span><span class="cov0" title="0">{
                config.SPIRESocketPath = os.Getenv("SPIRE_SOCKET_PATH")
                if config.SPIRESocketPath == "" </span><span class="cov0" title="0">{
                        config.SPIRESocketPath = "/tmp/spire-server/private/api.sock"
                }</span>
        }

        <span class="cov0" title="0">if config.SPIREServerPath == "" </span><span class="cov0" title="0">{
                config.SPIREServerPath = "spire-server"
        }</span>

        <span class="cov0" title="0">if config.Logger == nil </span><span class="cov0" title="0">{
                config.Logger = slog.Default()
        }</span>

        <span class="cov0" title="0">return &amp;Registrar{
                configProvider:  configProvider,
                spireSocketPath: config.SPIRESocketPath,
                spireServerPath: config.SPIREServerPath,
                logger:          config.Logger,
        }</span>
}

// RegisterService registers a service with SPIRE based on its configuration.
func (r *Registrar) RegisterService(ctx context.Context, configPath string) error <span class="cov0" title="0">{
        r.logger.Info("Starting service registration", "configPath", configPath)

        cfg, err := r.configProvider.LoadConfiguration(ctx, configPath)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to load configuration", "error", err)
                return fmt.Errorf("failed to load configuration: %w", errors.NewDomainError(errors.ErrMissingConfiguration, err))
        }</span>

        <span class="cov0" title="0">if err := r.validateConfig(cfg); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Invalid configuration", "error", err)
                return err
        }</span>

        // Create SPIRE registration entry
        <span class="cov0" title="0">if err := r.createSPIREEntry(ctx, cfg); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to create SPIRE entry", "error", err)
                return fmt.Errorf("SPIFFE registration failed: %w", errors.NewDomainError(errors.ErrSPIFFERegistration, err))
        }</span>

        <span class="cov0" title="0">r.logger.Info("Service registration completed successfully",
                "service", cfg.Service.Name,
                "domain", cfg.Service.Domain)

        return nil</span>
}

// validateConfig performs comprehensive validation of the configuration.
func (r *Registrar) validateConfig(cfg *ports.Configuration) error <span class="cov0" title="0">{
        // Validate service name
        if cfg.Service.Name == "" </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "Service.Name",
                        Value:   cfg.Service.Name,
                        Message: "service name is required",
                }
        }</span>

        // Validate service name format (alphanumeric with hyphens)
        <span class="cov0" title="0">validName := regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$`)
        if !validName.MatchString(cfg.Service.Name) </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "Service.Name",
                        Value:   cfg.Service.Name,
                        Message: "service name must be alphanumeric with optional hyphens",
                }
        }</span>

        // Validate domain
        <span class="cov0" title="0">if cfg.Service.Domain == "" </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "Service.Domain",
                        Value:   cfg.Service.Domain,
                        Message: "service domain is required",
                }
        }</span>

        // Validate domain format (basic DNS name validation)
        <span class="cov0" title="0">validDomain := regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9-.]*[a-zA-Z0-9])?$`)
        if !validDomain.MatchString(cfg.Service.Domain) </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "Service.Domain",
                        Value:   cfg.Service.Domain,
                        Message: "service domain must be a valid DNS name",
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createSPIREEntry creates a registration entry in SPIRE.
// NOTE: In production, you should use the SPIRE Server API directly via gRPC
// This implementation uses the CLI for simplicity, as the SPIRE Server API
// requires additional proto definitions not included in go-spiffe
//
//nolint:cyclop,funlen // Function has inherent complexity from validation and command execution
func (r *Registrar) createSPIREEntry(ctx context.Context, cfg *ports.Configuration) error <span class="cov0" title="0">{
        // Build SPIFFE IDs
        spiffeID, err := spiffeid.FromString(fmt.Sprintf("spiffe://%s/%s", cfg.Service.Domain, cfg.Service.Name))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse SPIFFE ID: %w", err)
        }</span>

        <span class="cov0" title="0">parentID, err := spiffeid.FromString(fmt.Sprintf("spiffe://%s/spire-agent", cfg.Service.Domain))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse parent ID: %w", err)
        }</span>

        // Get service selector
        <span class="cov0" title="0">selector := r.getServiceSelector()

        r.logger.Debug("Creating SPIRE entry",
                "spiffeID", spiffeID.String(),
                "parentID", parentID.String(),
                "selector", selector,
                "socketPath", r.spireSocketPath)

        // Validate paths for security
        if !isValidPath(r.spireServerPath) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid spire-server path: %s", r.spireServerPath)
        }</span>

        // Validate socket path for security
        <span class="cov0" title="0">if !isValidSocketPath(r.spireSocketPath) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid socket path: %s", r.spireSocketPath)
        }</span>

        // Validate selector format for security
        <span class="cov0" title="0">if !isValidSelector(selector) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid selector format: %s", selector)
        }</span>

        // Use spire-server CLI command
        // In production, use the SPIRE Server API directly
        //nolint:gosec // G204: Input is validated above for security
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, r.spireServerPath, "entry", "create",
                "-socketPath", r.spireSocketPath,
                "-spiffeID", spiffeID.String(),
                "-parentID", parentID.String(),
                "-selector", selector,
                "-ttl", "3600",
        )

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                outputStr := string(output)

                // Check if entry already exists (not an error)
                if strings.Contains(outputStr, "already exists") </span><span class="cov0" title="0">{
                        r.logger.Info("Registration entry already exists", "service", cfg.Service.Name)
                        return nil
                }</span>

                // Check for specific error conditions
                <span class="cov0" title="0">if strings.Contains(outputStr, "permission denied") </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission denied: ensure you have access to SPIRE socket at %s", r.spireSocketPath)
                }</span>

                <span class="cov0" title="0">if strings.Contains(outputStr, "connection refused") || strings.Contains(outputStr, "no such file") </span><span class="cov0" title="0">{
                        return fmt.Errorf("SPIRE server not running or not accessible at %s", r.spireSocketPath)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("SPIRE registration failed: %w\nOutput: %s", err, outputStr)</span>
        }

        <span class="cov0" title="0">r.logger.Info("Created SPIRE registration entry",
                "service", cfg.Service.Name,
                "output", string(output))

        return nil</span>
}

// getServiceSelector determines the service selector for SPIRE.
// For demo purposes, we use unix:uid selector (running as current user).
// In production, use more specific selectors like k8s:pod-label or unix:path.
func (r *Registrar) getServiceSelector() string <span class="cov0" title="0">{
        // For demo, use unix:uid selector with current user
        // This works when services run as the same user
        uid := os.Getuid()
        return fmt.Sprintf("unix:uid:%d", uid)
}</span>

// GetConfigProvider returns the configuration provider (for testing).
func (r *Registrar) GetConfigProvider() ports.ConfigurationProvider <span class="cov0" title="0">{
        return r.configProvider
}</span>

// GetSPIRESocketPath returns the SPIRE socket path (for testing).
func (r *Registrar) GetSPIRESocketPath() string <span class="cov0" title="0">{
        return r.spireSocketPath
}</span>

// GetSPIREServerPath returns the SPIRE server path (for testing).
func (r *Registrar) GetSPIREServerPath() string <span class="cov0" title="0">{
        return r.spireServerPath
}</span>

// ValidateConfig exposes validateConfig for testing.
func (r *Registrar) ValidateConfig(cfg *ports.Configuration) error <span class="cov0" title="0">{
        return r.validateConfig(cfg)
}</span>

// CreateSPIREEntry exposes createSPIREEntry for testing.
func (r *Registrar) CreateSPIREEntry(ctx context.Context, cfg *ports.Configuration) error <span class="cov0" title="0">{
        return r.createSPIREEntry(ctx, cfg)
}</span>

// GetServiceSelector exposes getServiceSelector for testing.
func (r *Registrar) GetServiceSelector() string <span class="cov0" title="0">{
        return r.getServiceSelector()
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package cli

import (
        "fmt"

        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{ //nolint:gochecknoglobals // Cobra command pattern
        Use:   "ephemos",
        Short: "Identity-based authentication CLI for SPIFFE/SPIRE services",
        Long: `Identity-based authentication CLI for SPIFFE/SPIRE services.

Ephemos provides identity-based authentication for backend services using SPIFFE/SPIRE.
Use this CLI to register services, manage identities, and configure authentication policies.`,
}

// Execute runs the CLI.
func Execute() error <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute command: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits // Cobra requires init for command setup
        rootCmd.AddCommand(registerCmd)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package config

import (
        "context"
        "fmt"
        "sync"

        "github.com/sufield/ephemos/internal/core/ports"
)

// InMemoryProvider is a real implementation of ConfigurationProvider that stores
// configurations in memory. This is useful for testing without mocks.
type InMemoryProvider struct {
        mu            sync.RWMutex
        configs       map[string]*ports.Configuration
        defaultConfig *ports.Configuration
}

// NewInMemoryProvider creates a new in-memory configuration provider.
func NewInMemoryProvider() *InMemoryProvider <span class="cov0" title="0">{
        return &amp;InMemoryProvider{
                configs: make(map[string]*ports.Configuration),
                defaultConfig: &amp;ports.Configuration{
                        Service: ports.ServiceConfig{
                                Name:   "default-service",
                                Domain: "default.org",
                        },
                        SPIFFE: &amp;ports.SPIFFEConfig{
                                SocketPath: "/tmp/spire-agent/public/api.sock",
                        },
                },
        }
}</span>

// SetConfiguration stores a configuration for a given path.
func (p *InMemoryProvider) SetConfiguration(path string, config *ports.Configuration) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.configs[path] = config
}</span>

// SetDefaultConfiguration updates the default configuration.
func (p *InMemoryProvider) SetDefaultConfiguration(config *ports.Configuration) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.defaultConfig = config
}</span>

// LoadConfiguration retrieves a configuration by path.
func (p *InMemoryProvider) LoadConfiguration(ctx context.Context, path string) (*ports.Configuration, error) <span class="cov0" title="0">{
        // Check for context cancellation
        if ctx != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, fmt.Errorf("context canceled: %w", ctx.Err())</span>
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">p.mu.RLock()
        defer p.mu.RUnlock()

        if path == "" </span><span class="cov0" title="0">{
                return p.defaultConfig, nil
        }</span>

        <span class="cov0" title="0">config, ok := p.configs[path]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration not found for path: %s", path)
        }</span>

        // Return a copy to prevent mutations
        <span class="cov0" title="0">return copyConfiguration(config), nil</span>
}

// GetDefaultConfiguration returns the default configuration.
func (p *InMemoryProvider) GetDefaultConfiguration(ctx context.Context) *ports.Configuration <span class="cov0" title="0">{
        // Check for context cancellation
        if ctx != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span> // Return nil on cancellation
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">p.mu.RLock()
        defer p.mu.RUnlock()
        return copyConfiguration(p.defaultConfig)</span>
}

// copyConfiguration creates a deep copy of a configuration.
func copyConfiguration(config *ports.Configuration) *ports.Configuration <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cfgCopy := &amp;ports.Configuration{
                Service: config.Service,
        }

        if config.SPIFFE != nil </span><span class="cov0" title="0">{
                cfgCopy.SPIFFE = &amp;ports.SPIFFEConfig{
                        SocketPath: config.SPIFFE.SocketPath,
                }
        }</span>

        <span class="cov0" title="0">if config.AuthorizedClients != nil </span><span class="cov0" title="0">{
                cfgCopy.AuthorizedClients = make([]string, len(config.AuthorizedClients))
                cfgCopy.AuthorizedClients = append(cfgCopy.AuthorizedClients, config.AuthorizedClients...)
        }</span>

        <span class="cov0" title="0">if config.TrustedServers != nil </span><span class="cov0" title="0">{
                cfgCopy.TrustedServers = make([]string, len(config.TrustedServers))
                cfgCopy.TrustedServers = append(cfgCopy.TrustedServers, config.TrustedServers...)
        }</span>

        <span class="cov0" title="0">return cfgCopy</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package config provides configuration management for Ephemos.
package config

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        yaml "gopkg.in/yaml.v3"

        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
)

// FileProvider provides configs from files.
type FileProvider struct{}

// NewFileProvider creates provider.
func NewFileProvider() *FileProvider <span class="cov0" title="0">{
        return &amp;FileProvider{}
}</span>

// LoadConfiguration loads config.
func (p *FileProvider) LoadConfiguration(ctx context.Context, path string) (*ports.Configuration, error) <span class="cov0" title="0">{
        // Validate and clean input path
        if strings.TrimSpace(path) == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "path",
                        Value:   path,
                        Message: "configuration file path cannot be empty or whitespace",
                }
        }</span>

        // Clean path first
        <span class="cov0" title="0">cleanPath := filepath.Clean(path)

        // Convert to absolute path to properly validate
        absPath, err := filepath.Abs(cleanPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve config file path: %w", err)
        }</span>

        // Use the absolute path for reading
        <span class="cov0" title="0">cleanPath = absPath

        // Check for context cancellation
        if ctx != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, fmt.Errorf("configuration loading canceled: %w", ctx.Err())</span>
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">data, err := os.ReadFile(cleanPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">var config ports.Configuration
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file %s: %w", path, err)
        }</span>

        // Validate the loaded configuration
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration in file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// GetDefaultConfiguration gets default.
func (p *FileProvider) GetDefaultConfiguration(_ context.Context) *ports.Configuration <span class="cov0" title="0">{
        // GetDefaultConfiguration should always return a default configuration
        // regardless of context state, as it doesn't perform any blocking operations

        return &amp;ports.Configuration{
                Service: ports.ServiceConfig{
                        Name:   "ephemos-service", // Default service name
                        Domain: "",                // Empty domain uses SPIRE trust domain
                },
                SPIFFE: &amp;ports.SPIFFEConfig{
                        SocketPath: "/tmp/spire-agent/public/api.sock", // Standard SPIRE agent socket path
                },
                AuthorizedClients: []string{}, // Empty list - no client restrictions by default
                TrustedServers:    []string{}, // Empty list - trust all servers by default (not recommended for production)
        }
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package api provides high-level client and server APIs for secure SPIFFE-based communication.
package api

import (
        "context"
        "fmt"
        "net"
        "strings"
        "sync"

        "google.golang.org/grpc"

        "github.com/sufield/ephemos/internal/adapters/secondary/config"
        "github.com/sufield/ephemos/internal/adapters/secondary/spiffe"
        "github.com/sufield/ephemos/internal/adapters/secondary/transport"
        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
        "github.com/sufield/ephemos/internal/core/services"
)

// IdentityClient provides a high-level API for connecting to SPIFFE-secured services.
type IdentityClient struct {
        identityService *services.IdentityService
        domainClient    ports.Client
        mu              sync.Mutex
}

// NewIdentityClient creates a new IdentityClient with the given configuration file path.
func NewIdentityClient(ctx context.Context, configPath string) (*IdentityClient, error) <span class="cov0" title="0">{
        configProvider := config.NewFileProvider()

        var cfg *ports.Configuration
        var err error

        if configPath != "" </span><span class="cov0" title="0">{
                cfg, err = configProvider.LoadConfiguration(ctx, configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load configuration: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                cfg = configProvider.GetDefaultConfiguration(ctx)
                if cfg == nil </span><span class="cov0" title="0">{
                        return nil, &amp;errors.ValidationError{
                                Field:   "configuration",
                                Value:   nil,
                                Message: "no configuration provided and no default configuration available",
                        }
                }</span>
        }

        <span class="cov0" title="0">spiffeProvider, err := spiffe.NewProvider(cfg.SPIFFE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SPIFFE provider: %w", err)
        }</span>

        <span class="cov0" title="0">transportProvider := transport.NewGRPCProvider(spiffeProvider)

        identityService, err := services.NewIdentityService(
                spiffeProvider,
                transportProvider,
                cfg,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create identity service: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;IdentityClient{
                identityService: identityService,
        }, nil</span>
}

// Connect establishes a secure connection to a remote service using SPIFFE identities.
func (c *IdentityClient) Connect(ctx context.Context, serviceName, address string) (*ClientConnection, error) <span class="cov0" title="0">{
        // Input validation
        if ctx == nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "context",
                        Value:   nil,
                        Message: "context cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(serviceName) == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "serviceName",
                        Value:   serviceName,
                        Message: "service name cannot be empty or whitespace",
                }
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(address) == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "address",
                        Value:   address,
                        Message: "address cannot be empty or whitespace",
                }
        }</span>

        // Validate address format (host:port)
        <span class="cov0" title="0">if _, _, err := net.SplitHostPort(address); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "address",
                        Value:   address,
                        Message: "address must be in format 'host:port'",
                }
        }</span>

        <span class="cov0" title="0">serviceName = strings.TrimSpace(serviceName)
        address = strings.TrimSpace(address)

        // Thread-safe connection initialization
        c.mu.Lock()
        if c.domainClient == nil </span><span class="cov0" title="0">{
                client, err := c.identityService.CreateClientIdentity()
                if err != nil </span><span class="cov0" title="0">{
                        c.mu.Unlock()
                        return nil, fmt.Errorf("failed to create client identity: %w", err)
                }</span>
                <span class="cov0" title="0">c.domainClient = client</span>
        }
        <span class="cov0" title="0">c.mu.Unlock()

        domainConn, err := c.domainClient.Connect(serviceName, address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to service %s at %s: %w", serviceName, address, err)
        }</span>

        // Extract the underlying gRPC connection
        <span class="cov0" title="0">grpcConn, ok := domainConn.GetClientConnection().(*grpc.ClientConn)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected connection type from domain client")
        }</span>

        <span class="cov0" title="0">return &amp;ClientConnection{conn: grpcConn, domainConn: domainConn}, nil</span>
}

// Close cleans up the client resources and closes any connections.
func (c *IdentityClient) Close() error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.domainClient != nil </span><span class="cov0" title="0">{
                if err := c.domainClient.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close domain client: %w", err)
                }</span>
                <span class="cov0" title="0">c.domainClient = nil</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ClientConnection represents a secure client connection to a remote service.
type ClientConnection struct {
        conn       *grpc.ClientConn
        domainConn ports.Connection
}

// Close terminates the client connection and cleans up resources.
func (c *ClientConnection) Close() error <span class="cov0" title="0">{
        if c.domainConn != nil </span><span class="cov0" title="0">{
                if err := c.domainConn.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close domain connection: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetClientConnection returns the underlying gRPC client connection.
func (c *ClientConnection) GetClientConnection() *grpc.ClientConn <span class="cov0" title="0">{
        return c.conn
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package api

import (
        "context"
        "fmt"
        "log/slog"
        "net"
        "sync"

        "google.golang.org/grpc"

        "github.com/sufield/ephemos/internal/adapters/secondary/config"
        "github.com/sufield/ephemos/internal/adapters/secondary/spiffe"
        "github.com/sufield/ephemos/internal/adapters/secondary/transport"
        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
        "github.com/sufield/ephemos/internal/core/services"
)

// IdentityServer provides a secure gRPC server with SPIFFE-based identity management.
type IdentityServer struct {
        identityService *services.IdentityService
        configProvider  ports.ConfigurationProvider
        serviceName     string
        domainServer    ports.Server
        mu              sync.Mutex
}

// NewIdentityServer creates a new identity server with the given configuration.
func NewIdentityServer(ctx context.Context, configPath string) (*IdentityServer, error) <span class="cov0" title="0">{
        configProvider := config.NewFileProvider()

        var cfg *ports.Configuration
        var err error
        if configPath != "" </span><span class="cov0" title="0">{
                cfg, err = configProvider.LoadConfiguration(ctx, configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load configuration: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                cfg = configProvider.GetDefaultConfiguration(ctx)
                if cfg == nil </span><span class="cov0" title="0">{
                        return nil, &amp;errors.ValidationError{
                                Field:   "configuration",
                                Value:   nil,
                                Message: "no configuration provided and no default configuration available",
                        }
                }</span>
        }

        <span class="cov0" title="0">spiffeProvider, err := spiffe.NewProvider(cfg.SPIFFE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SPIFFE provider: %w", err)
        }</span>

        <span class="cov0" title="0">transportProvider := transport.NewGRPCProvider(spiffeProvider)

        identityService, err := services.NewIdentityService(
                spiffeProvider,
                transportProvider,
                cfg,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create identity service: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;IdentityServer{
                identityService: identityService,
                configProvider:  configProvider,
                serviceName:     cfg.Service.Name,
        }, nil</span>
}

// RegisterService registers a gRPC service with the identity server.
func (s *IdentityServer) RegisterService(ctx context.Context, serviceRegistrar ServiceRegistrar) error <span class="cov0" title="0">{
        // Input validation
        if serviceRegistrar == nil </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "serviceRegistrar",
                        Value:   serviceRegistrar,
                        Message: "service registrar cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        if s.domainServer == nil </span><span class="cov0" title="0">{
                if err := s.initializeServer(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize server: %w", err)
                }</span>
        }

        // Adapt our ServiceRegistrar to ports.ServiceRegistrar
        <span class="cov0" title="0">portServiceRegistrar := &amp;serviceRegistrarAdapter{registrar: serviceRegistrar}
        if err := s.domainServer.RegisterService(portServiceRegistrar); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register service: %w", err)
        }</span>

        <span class="cov0" title="0">slog.Info("Service registered successfully", "service", s.serviceName)
        return nil</span>
}

// Serve starts the identity server on the provided listener.
func (s *IdentityServer) Serve(ctx context.Context, listener net.Listener) error <span class="cov0" title="0">{
        // Input validation
        if listener == nil </span><span class="cov0" title="0">{
                return &amp;errors.ValidationError{
                        Field:   "listener",
                        Value:   listener,
                        Message: "listener cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        if s.domainServer == nil </span><span class="cov0" title="0">{
                if err := s.initializeServer(ctx); err != nil </span><span class="cov0" title="0">{
                        s.mu.Unlock()
                        return fmt.Errorf("failed to initialize server: %w", err)
                }</span>
        }
        <span class="cov0" title="0">s.mu.Unlock()

        slog.Info("Server ready", "service", s.serviceName, "address", listener.Addr().String())

        // Adapt net.Listener to ports.Listener
        portListener := transport.NewNetListener(listener)
        if err := s.domainServer.Start(portListener); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve domain server: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Close gracefully shuts down the identity server.
func (s *IdentityServer) Close() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.domainServer != nil </span><span class="cov0" title="0">{
                if err := s.domainServer.Stop(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to stop server: %w", err)
                }</span>
                <span class="cov0" title="0">slog.Info("Server stopped gracefully", "service", s.serviceName)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *IdentityServer) initializeServer(_ context.Context) error <span class="cov0" title="0">{
        server, err := s.identityService.CreateServerIdentity()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create server identity: %w", err)
        }</span>
        <span class="cov0" title="0">s.domainServer = server
        slog.Info("Server identity created", "service", s.serviceName)
        return nil</span>
}

// serviceRegistrarAdapter adapts our API ServiceRegistrar to ports.ServiceRegistrar.
type serviceRegistrarAdapter struct {
        registrar ServiceRegistrar
}

func (a *serviceRegistrarAdapter) Register(server interface{}) <span class="cov0" title="0">{
        if grpcServer, ok := server.(*grpc.Server); ok </span><span class="cov0" title="0">{
                a.registrar.Register(grpcServer)
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package api

import (
        "context"
        "fmt"
        "sync"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// TestService is a simple gRPC service for testing purposes.
// It provides real functionality rather than mocks.
type TestService struct {
        UnimplementedTestServiceServer
        mu         sync.RWMutex
        callCount  int
        lastInput  string
        shouldFail bool
        failCode   codes.Code
}

// NewTestService creates a new test service with configurable behavior.
func NewTestService() *TestService <span class="cov0" title="0">{
        return &amp;TestService{
                failCode: codes.Internal,
        }
}</span>

// SetShouldFail configures the service to fail with the specified error code.
func (s *TestService) SetShouldFail(shouldFail bool, code codes.Code) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.shouldFail = shouldFail
        s.failCode = code
}</span>

// GetCallCount returns the number of times the service was called.
func (s *TestService) GetCallCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.callCount
}</span>

// GetLastInput returns the last input received by the service.
func (s *TestService) GetLastInput() string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.lastInput
}</span>

// TestMethod implements a simple test RPC method.
func (s *TestService) TestMethod(_ context.Context, req *TestRequest) (*TestResponse, error) <span class="cov0" title="0">{
        s.mu.Lock()
        s.callCount++
        s.lastInput = req.GetInput()
        shouldFail := s.shouldFail
        failCode := s.failCode
        s.mu.Unlock()

        if shouldFail </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("test service failure: %w", status.Error(failCode, "simulated failure"))
        }</span>

        <span class="cov0" title="0">return &amp;TestResponse{
                Output: "processed: " + req.GetInput(),
        }, nil</span>
}

// TestServiceRegistrar is a real implementation of ServiceRegistrar for testing.
// It registers a real gRPC service, not a mock.
type TestServiceRegistrar struct {
        service       *TestService
        registered    bool
        registerCount int
        mu            sync.Mutex
}

// NewTestServiceRegistrar creates a new test service registrar.
func NewTestServiceRegistrar(service *TestService) *TestServiceRegistrar <span class="cov0" title="0">{
        if service == nil </span><span class="cov0" title="0">{
                service = NewTestService()
        }</span>
        <span class="cov0" title="0">return &amp;TestServiceRegistrar{
                service: service,
        }</span>
}

// Register registers the test service with the gRPC server.
func (r *TestServiceRegistrar) Register(server *grpc.Server) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if server != nil </span><span class="cov0" title="0">{
                // In a real scenario, this would be:
                // RegisterTestServiceServer(server, r.service)
                // For now, we just track that it was called
                r.registered = true
                r.registerCount++
        }</span>
}

// IsRegistered returns whether the service has been registered.
func (r *TestServiceRegistrar) IsRegistered() bool <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        return r.registered
}</span>

// GetRegisterCount returns how many times Register was called.
func (r *TestServiceRegistrar) GetRegisterCount() int <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        return r.registerCount
}</span>

// GetService returns the underlying test service.
func (r *TestServiceRegistrar) GetService() *TestService <span class="cov0" title="0">{
        return r.service
}</span>

// TestRequest represents a test request message for gRPC testing.
type TestRequest struct {
        Input string
}

// GetInput returns the input field of the test request.
func (r *TestRequest) GetInput() string <span class="cov0" title="0">{
        if r != nil </span><span class="cov0" title="0">{
                return r.Input
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// TestResponse represents a test response message for gRPC testing.
type TestResponse struct {
        Output string
}

// GetOutput returns the output field of the test response.
func (r *TestResponse) GetOutput() string <span class="cov0" title="0">{
        if r != nil </span><span class="cov0" title="0">{
                return r.Output
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// UnimplementedTestServiceServer is a minimal implementation for forward compatibility.
type UnimplementedTestServiceServer struct{}

// TestMethod provides an unimplemented test method for forward compatibility.
func (UnimplementedTestServiceServer) TestMethod(context.Context, *TestRequest) (*TestResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method TestMethod not implemented")
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">// Package spiffe provides SPIFFE identity management and X.509 certificate handling.
package spiffe

import (
        "context"
        "fmt"
        "strings"

        "github.com/spiffe/go-spiffe/v2/spiffeid"
        "github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig"
        "github.com/spiffe/go-spiffe/v2/workloadapi"

        "github.com/sufield/ephemos/internal/core/domain"
        "github.com/sufield/ephemos/internal/core/ports"
)

// Provider provides SPIFFE identities.
type Provider struct {
        socketPath string
        x509Source *workloadapi.X509Source
}

// NewProvider creates a provider.
func NewProvider(config *ports.SPIFFEConfig) (*Provider, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                // Use default socket path when no config is provided
                return &amp;Provider{
                        socketPath: "/tmp/spire-agent/public/api.sock",
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;Provider{
                socketPath: config.SocketPath,
        }, nil</span>
}

// GetServiceIdentity fetches identity.
func (p *Provider) GetServiceIdentity() (*domain.ServiceIdentity, error) <span class="cov0" title="0">{
        ctx := context.Background() // Context managed at adapter layer
        if err := p.ensureSource(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">svid, err := p.x509Source.GetX509SVID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get X509 SVID: %w", err)
        }</span>

        <span class="cov0" title="0">id := svid.ID
        serviceName := "unknown"
        path := id.Path()
        if path != "" &amp;&amp; len(path) &gt; 1 </span><span class="cov0" title="0">{
                // Remove leading slash and split by remaining slashes
                pathSegments := strings.Split(strings.TrimPrefix(path, "/"), "/")
                if len(pathSegments) &gt; 0 &amp;&amp; pathSegments[0] != "" </span><span class="cov0" title="0">{
                        serviceName = pathSegments[0]
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.ServiceIdentity{
                Name:   serviceName,
                Domain: id.TrustDomain().String(),
                URI:    id.String(),
        }, nil</span>
}

// GetCertificate fetches cert.
func (p *Provider) GetCertificate() (*domain.Certificate, error) <span class="cov0" title="0">{
        ctx := context.Background() // Context managed at adapter layer
        if err := p.ensureSource(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">svid, err := p.x509Source.GetX509SVID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get X509 SVID: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;domain.Certificate{
                Cert:       svid.Certificates[0],
                PrivateKey: svid.PrivateKey,
                Chain:      svid.Certificates,
        }, nil</span>
}

// GetTrustBundle fetches bundle.
func (p *Provider) GetTrustBundle() (*domain.TrustBundle, error) <span class="cov0" title="0">{
        ctx := context.Background() // Context managed at adapter layer
        if err := p.ensureSource(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">bundle, err := p.x509Source.GetX509BundleForTrustDomain(spiffeid.RequireTrustDomainFromString("example.org"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trust bundle: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;domain.TrustBundle{
                Certificates: bundle.X509Authorities(),
        }, nil</span>
}

func (p *Provider) ensureSource(ctx context.Context) error <span class="cov0" title="0">{
        if p.x509Source != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">source, err := workloadapi.NewX509Source(
                ctx,
                workloadapi.WithClientOptions(
                        workloadapi.WithAddr("unix://"+p.socketPath),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create X509 source: %w", err)
        }</span>

        <span class="cov0" title="0">p.x509Source = source
        return nil</span>
}

// GetTLSConfig gets TLS config.
func (p *Provider) GetTLSConfig(ctx context.Context) (tlsconfig.Authorizer, error) <span class="cov0" title="0">{
        if err := p.ensureSource(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tlsconfig.AuthorizeAny(), nil</span>
}

// GetX509Source returns source.
func (p *Provider) GetX509Source() *workloadapi.X509Source <span class="cov0" title="0">{
        return p.x509Source
}</span>

// GetSocketPath returns path.
func (p *Provider) GetSocketPath() string <span class="cov0" title="0">{
        return p.socketPath
}</span>

// Close closes the provider.
func (p *Provider) Close() error <span class="cov0" title="0">{
        if p.x509Source != nil </span><span class="cov0" title="0">{
                if err := p.x509Source.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close X509 source: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Package ephemos provides identity-based authentication for backend services using SPIFFE/SPIRE.
// It abstracts away all SPIFFE/SPIRE complexity, making identity-based authentication as simple as using API keys.
package ephemos

import (
        "context"
        "fmt"
        "net"
        "os"
        "strings"

        "google.golang.org/grpc"

        "github.com/sufield/ephemos/internal/adapters/interceptors"
        "github.com/sufield/ephemos/internal/adapters/primary/api"
        "github.com/sufield/ephemos/internal/core/errors"
        "github.com/sufield/ephemos/internal/core/ports"
)

// ServiceRegistrar is the interface that service implementations must implement.
// Implementations should register their gRPC service with the provided server.
// This interface abstracts away gRPC registration details from service developers.
//
// Most developers should use the generic NewServiceRegistrar function instead of
// implementing this interface directly:
//
//        // Recommended approach (no boilerplate):
//        registrar := ephemos.NewServiceRegistrar(func(s *grpc.Server) {
//                proto.RegisterYourServiceServer(s, &amp;yourService{})
//        })
//
// Advanced users can implement this interface directly for custom registration logic.
type ServiceRegistrar = api.ServiceRegistrar

// GenericServiceRegistrar is a generic implementation that can register any gRPC service
// without requiring developers to write service-specific registrars. This eliminates
// boilerplate code and makes service registration a one-liner.
//
// Example usage:
//
//        // Instead of writing a custom registrar, use the generic one:
//        registrar := ephemos.NewServiceRegistrar(func(s *grpc.Server) {
//                proto.RegisterYourServiceServer(s, &amp;YourServiceImpl{})
//        })
//        server.RegisterService(ctx, registrar)
type GenericServiceRegistrar struct {
        registerFunc func(*grpc.Server)
}

// NewServiceRegistrar creates a generic registrar that can be used for any gRPC service.
// This eliminates the need to write service-specific registrars, reducing boilerplate code.
//
// Parameters:
//   - registerFunc: A function that registers your service with the gRPC server.
//     This is typically just calling your generated Register*Server function.
//
// Example:
//
//        // For an Echo service:
//        registrar := ephemos.NewServiceRegistrar(func(s *grpc.Server) {
//                proto.RegisterEchoServiceServer(s, &amp;MyEchoServer{})
//        })
//
//        // For any other service:
//        registrar := ephemos.NewServiceRegistrar(func(s *grpc.Server) {
//                proto.RegisterUserServiceServer(s, &amp;MyUserService{})
//        })
func NewServiceRegistrar(registerFunc func(*grpc.Server)) ServiceRegistrar <span class="cov10" title="7">{
        return &amp;GenericServiceRegistrar{
                registerFunc: registerFunc,
        }
}</span>

// Register implements the ServiceRegistrar interface by calling the provided registration function.
func (r *GenericServiceRegistrar) Register(grpcServer *grpc.Server) <span class="cov9" title="6">{
        if r.registerFunc != nil </span><span class="cov8" title="5">{
                r.registerFunc(grpcServer)
        }</span>
}

// Server represents an identity-aware gRPC server that handles automatic mTLS authentication.
// Services registered with this server will automatically use SPIFFE/SPIRE for identity verification.
// The server handles all certificate management and peer authentication transparently.
//
// Usage:
//
//        ctx := context.Background()
//        server, err := ephemos.NewIdentityServer(ctx, "")
//        if err != nil {
//                log.Fatal(err)
//        }
//        defer server.Close() // Ensure proper cleanup
//
//        serviceRegistrar := proto.NewYourServiceRegistrar(&amp;yourService{})
//        server.RegisterService(ctx, serviceRegistrar)
//
//        lis, _ := net.Listen("tcp", ":50051")
//        defer lis.Close() // Ensure listener cleanup
//        server.Serve(ctx, lis)
type Server interface {
        // RegisterService registers a gRPC service implementation with the server.
        // The serviceRegistrar must implement the ServiceRegistrar interface.
        // The context can be used for cancellation and timeouts during initialization.
        // Returns an error if registration fails or if serviceRegistrar is nil.
        RegisterService(ctx context.Context, serviceRegistrar ServiceRegistrar) error

        // Serve starts the server and listens for incoming connections on the provided listener.
        // The context can be used for cancellation and timeouts during server initialization.
        // This method blocks until the server is shut down or the context is canceled.
        // The caller should defer listener.Close() to ensure proper resource cleanup.
        Serve(ctx context.Context, listener net.Listener) error

        // Close gracefully shuts down the server and releases resources.
        // Should be called when the server is no longer needed.
        Close() error
}

// Client represents an identity-aware gRPC client that handles automatic mTLS authentication.
// Connections made through this client will automatically use SPIFFE/SPIRE for identity verification.
// The client handles all certificate management and server authentication transparently.
//
// Usage:
//
//        ctx := context.Background()
//        client, err := ephemos.NewIdentityClient(ctx, "")
//        if err != nil {
//                log.Fatal(err)
//        }
//        defer client.Close() // Ensure proper cleanup
//
//        conn, err := client.Connect(ctx, "service-name", "localhost:50051")
//        if err != nil {
//                log.Fatal(err)
//        }
//        defer conn.Close() // Always defer connection cleanup
type Client interface {
        // Connect establishes a connection to the specified service at the given address.
        // The serviceName is used for identity verification and must be non-empty.
        // The address should be in the format "host:port" and must be non-empty.
        // The context can be used for cancellation and timeouts.
        // Returns a ClientConnection that provides access to the underlying gRPC connection.
        // The caller must call Close() on the returned connection to release resources.
        Connect(ctx context.Context, serviceName, address string) (*api.ClientConnection, error)

        // Close releases any resources held by the client.
        // Should be called when the client is no longer needed.
        Close() error
}

// NewIdentityServer creates a new identity-aware server instance.
// It reads configuration from the EPHEMOS_CONFIG environment variable or uses defaults.
// The server will automatically handle mTLS authentication using SPIFFE/SPIRE.
// Returns an error if server creation fails, allowing callers to handle failures gracefully.
//
// Example:
//
//        ctx := context.Background()
//        server, err := ephemos.NewIdentityServer(ctx, "")
//        if err != nil {
//                return fmt.Errorf("failed to create server: %w", err)
//        }
//        defer server.Close()
//
//        registrar := ephemos.NewServiceRegistrar(func(s *grpc.Server) {
//                proto.RegisterYourServiceServer(s, &amp;myService{})
//        })
//        server.RegisterService(ctx, registrar)
//        lis, _ := net.Listen("tcp", ":50051")
//        defer lis.Close()
//        server.Serve(ctx, lis)
func NewIdentityServer(ctx context.Context, configPath string) (Server, error) <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "context",
                        Value:   nil,
                        Message: "context cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">validConfigPath, err := validateConfigPath(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config path: %w", err)
        }</span>

        <span class="cov0" title="0">server, err := api.NewIdentityServer(ctx, validConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create identity server: %w", err)
        }</span>

        <span class="cov0" title="0">return server, nil</span>
}

// NewIdentityClient creates a new identity-aware client instance.
// It reads configuration from the EPHEMOS_CONFIG environment variable or uses defaults.
// The client will automatically handle mTLS authentication using SPIFFE/SPIRE.
// Returns an error if client creation fails, allowing callers to handle failures gracefully.
//
// Example:
//
//        ctx := context.Background()
//        client, err := ephemos.NewIdentityClient(ctx, "")
//        if err != nil {
//                return fmt.Errorf("failed to create client: %w", err)
//        }
//        defer client.Close()
//
//        conn, err := client.Connect(ctx, "my-service", "localhost:50051")
//        if err != nil {
//                return fmt.Errorf("failed to connect: %w", err)
//        }
//        defer conn.Close()
//
//        serviceClient := proto.NewServiceClient(conn.GetClientConnection())
func NewIdentityClient(ctx context.Context, configPath string) (Client, error) <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.ValidationError{
                        Field:   "context",
                        Value:   nil,
                        Message: "context cannot be nil",
                }
        }</span>

        <span class="cov0" title="0">validConfigPath, err := validateConfigPath(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config path: %w", err)
        }</span>

        <span class="cov0" title="0">client, err := api.NewIdentityClient(ctx, validConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create identity client: %w", err)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// validateConfigPath validates and returns a proper config path.
// If configPath is empty, it checks EPHEMOS_CONFIG environment variable.
// Returns an error if validation fails.
func validateConfigPath(configPath string) (string, error) <span class="cov0" title="0">{
        // If explicitly provided, validate it
        if configPath != "" </span><span class="cov0" title="0">{
                if strings.TrimSpace(configPath) == "" </span><span class="cov0" title="0">{
                        return "", &amp;errors.ValidationError{
                                Field:   "configPath",
                                Value:   configPath,
                                Message: "config path cannot be whitespace only",
                        }
                }</span>
                <span class="cov0" title="0">return strings.TrimSpace(configPath), nil</span>
        }

        // Check environment variable
        <span class="cov0" title="0">envConfig := os.Getenv("EPHEMOS_CONFIG")
        if envConfig != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(envConfig), nil
        }</span>

        // Return empty string to use defaults
        <span class="cov0" title="0">return "", nil</span>
}

// Built-in Interceptors

// InterceptorConfig provides configuration for built-in interceptors.
type InterceptorConfig struct {
        // EnableAuth enables authentication interceptor
        EnableAuth bool
        // AuthConfig configuration for authentication
        AuthConfig *interceptors.AuthConfig

        // EnableIdentityPropagation enables identity propagation for outgoing calls
        EnableIdentityPropagation bool
        // IdentityPropagationConfig configuration for identity propagation
        IdentityPropagationConfig *interceptors.IdentityPropagationConfig

        // EnableLogging enables audit logging interceptor
        EnableLogging bool
        // LoggingConfig configuration for logging
        LoggingConfig *interceptors.LoggingConfig

        // EnableMetrics enables metrics collection interceptor
        EnableMetrics bool
        // MetricsConfig configuration for metrics
        MetricsConfig *interceptors.MetricsConfig
}

// NewDefaultInterceptorConfig creates a default interceptor configuration.
func NewDefaultInterceptorConfig() *InterceptorConfig <span class="cov0" title="0">{
        return &amp;InterceptorConfig{
                EnableAuth:                true,
                AuthConfig:                interceptors.DefaultAuthConfig(),
                EnableIdentityPropagation: false, // Disabled by default
                EnableLogging:             true,
                LoggingConfig:             interceptors.NewSecureLoggingConfig(),
                EnableMetrics:             true,
                MetricsConfig:             interceptors.DefaultMetricsConfig("ephemos-service"),
        }
}</span>

// NewProductionInterceptorConfig creates a production-ready interceptor configuration.
func NewProductionInterceptorConfig(serviceName string) *InterceptorConfig <span class="cov0" title="0">{
        return &amp;InterceptorConfig{
                EnableAuth:                true,
                AuthConfig:                interceptors.DefaultAuthConfig(),
                EnableIdentityPropagation: true,
                EnableLogging:             true,
                LoggingConfig:             interceptors.NewSecureLoggingConfig(),
                EnableMetrics:             true,
                MetricsConfig:             interceptors.DefaultMetricsConfig(serviceName),
        }
}</span>

// NewDevelopmentInterceptorConfig creates a development-friendly interceptor configuration.
func NewDevelopmentInterceptorConfig(serviceName string) *InterceptorConfig <span class="cov0" title="0">{
        return &amp;InterceptorConfig{
                EnableAuth:                false, // Disabled for easier development
                AuthConfig:                interceptors.DefaultAuthConfig(),
                EnableIdentityPropagation: true,
                EnableLogging:             true,
                LoggingConfig:             interceptors.NewDebugLoggingConfig(),
                EnableMetrics:             true,
                MetricsConfig:             interceptors.DefaultMetricsConfig(serviceName),
        }
}</span>

// CreateServerInterceptors creates gRPC server interceptors based on configuration.
func CreateServerInterceptors(
        config *InterceptorConfig,
        _ ports.IdentityProvider,
) ([]grpc.UnaryServerInterceptor, []grpc.StreamServerInterceptor) <span class="cov0" title="0">{
        var unaryInterceptors []grpc.UnaryServerInterceptor
        var streamInterceptors []grpc.StreamServerInterceptor

        // Identity propagation server interceptor (extracts metadata)
        if config.EnableIdentityPropagation </span><span class="cov0" title="0">{
                serverPropagation := interceptors.NewIdentityPropagationServerInterceptor(config.LoggingConfig.Logger)
                unaryInterceptors = append(unaryInterceptors, serverPropagation.UnaryServerInterceptor())
                streamInterceptors = append(streamInterceptors, serverPropagation.StreamServerInterceptor())
        }</span>

        // Authentication interceptor
        <span class="cov0" title="0">if config.EnableAuth </span><span class="cov0" title="0">{
                authInterceptor := interceptors.NewAuthInterceptor(config.AuthConfig)
                unaryInterceptors = append(unaryInterceptors, authInterceptor.UnaryServerInterceptor())
                streamInterceptors = append(streamInterceptors, authInterceptor.StreamServerInterceptor())
        }</span>

        // Logging interceptor
        <span class="cov0" title="0">if config.EnableLogging </span><span class="cov0" title="0">{
                loggingInterceptor := interceptors.NewLoggingInterceptor(config.LoggingConfig)
                unaryInterceptors = append(unaryInterceptors, loggingInterceptor.UnaryServerInterceptor())
                streamInterceptors = append(streamInterceptors, loggingInterceptor.StreamServerInterceptor())
        }</span>

        // Metrics interceptor
        <span class="cov0" title="0">if config.EnableMetrics </span><span class="cov0" title="0">{
                metricsInterceptor := interceptors.NewMetricsInterceptor(config.MetricsConfig)
                unaryInterceptors = append(unaryInterceptors, metricsInterceptor.UnaryServerInterceptor())
                streamInterceptors = append(streamInterceptors, metricsInterceptor.StreamServerInterceptor())
        }</span>

        <span class="cov0" title="0">return unaryInterceptors, streamInterceptors</span>
}

// CreateClientInterceptors creates gRPC client interceptors based on configuration.
func CreateClientInterceptors(
        config *InterceptorConfig,
        identityProvider ports.IdentityProvider,
) ([]grpc.UnaryClientInterceptor, []grpc.StreamClientInterceptor) <span class="cov0" title="0">{
        var unaryInterceptors []grpc.UnaryClientInterceptor
        var streamInterceptors []grpc.StreamClientInterceptor

        // Identity propagation client interceptor (adds metadata)
        if config.EnableIdentityPropagation &amp;&amp; identityProvider != nil </span><span class="cov0" title="0">{
                if config.IdentityPropagationConfig == nil </span><span class="cov0" title="0">{
                        config.IdentityPropagationConfig = interceptors.DefaultIdentityPropagationConfig(identityProvider)
                }</span>
                <span class="cov0" title="0">config.IdentityPropagationConfig.IdentityProvider = identityProvider

                clientPropagation := interceptors.NewIdentityPropagationInterceptor(config.IdentityPropagationConfig)
                unaryInterceptors = append(unaryInterceptors, clientPropagation.UnaryClientInterceptor())
                streamInterceptors = append(streamInterceptors, clientPropagation.StreamClientInterceptor())</span>
        }

        // Metrics interceptor
        <span class="cov0" title="0">if config.EnableMetrics </span><span class="cov0" title="0">{
                metricsInterceptor := interceptors.NewMetricsInterceptor(config.MetricsConfig)
                unaryInterceptors = append(unaryInterceptors, metricsInterceptor.UnaryClientInterceptor())
                streamInterceptors = append(streamInterceptors, metricsInterceptor.StreamClientInterceptor())
        }</span>

        <span class="cov0" title="0">return unaryInterceptors, streamInterceptors</span>
}

// Legacy compatibility functions - deprecated, use New* functions instead

// IdentityServer creates a new identity-aware server instance.
// Deprecated: Use NewIdentityServer for better error handling.
func IdentityServer() Server <span class="cov0" title="0">{
        ctx := context.Background()
        server, err := NewIdentityServer(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to create identity server: %v", err))</span>
        }
        <span class="cov0" title="0">return server</span>
}

// IdentityClient creates a new identity-aware client instance.
// Deprecated: Use NewIdentityClient for better error handling.
func IdentityClient() Client <span class="cov0" title="0">{
        ctx := context.Background()
        client, err := NewIdentityClient(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to create identity client: %v", err))</span>
        }
        <span class="cov0" title="0">return client</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
