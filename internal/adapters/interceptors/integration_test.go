package interceptors

import (
	"context"
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"google.golang.org/grpc/test/bufconn"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/sufield/ephemos/internal/core/domain"
)

const bufSize = 1024 * 1024

// Test service implementation.
type testServiceImpl struct{}

func (s *testServiceImpl) TestMethod(ctx context.Context, _ *TestRequest) (*TestResponse, error) {
	// Check if identity is available in context
	identity, ok := GetIdentityFromContext(ctx)
	if ok {
		return &TestResponse{
			Message: fmt.Sprintf("Hello from %s", identity.ServiceName),
		}, nil
	}
	return &TestResponse{Message: "Hello anonymous"}, nil
}

func (s *testServiceImpl) TestStream(stream TestServiceTestStreamServer) error {
	for {
		req, err := stream.Recv()
		if err != nil {
			return fmt.Errorf("failed to receive stream message: %w", err)
		}

		// Echo back the request
		err = stream.Send(&TestResponse{
			Message: fmt.Sprintf("Echo: %s", req.Message),
		})
		if err != nil {
			return fmt.Errorf("failed to send stream response: %w", err)
		}
	}
}

// Mock proto definitions for testing.
type TestRequest struct {
	Message string
}

func (r *TestRequest) Reset()         { *r = TestRequest{} }
func (r *TestRequest) String() string { return r.Message }
func (r *TestRequest) ProtoMessage()  {}

type TestResponse struct {
	Message string
}

func (r *TestResponse) Reset()         { *r = TestResponse{} }
func (r *TestResponse) String() string { return r.Message }
func (r *TestResponse) ProtoMessage()  {}

type TestServiceTestStreamServer interface {
	grpc.ServerStream
	Send(*TestResponse) error
	Recv() (*TestRequest, error)
}

type TestServiceServer interface {
	TestMethod(context.Context, *TestRequest) (*TestResponse, error)
	TestStream(TestServiceTestStreamServer) error
}

type TestServiceClient interface {
	TestMethod(ctx context.Context, req *TestRequest, opts ...grpc.CallOption) (*TestResponse, error)
	TestStream(ctx context.Context, opts ...grpc.CallOption) (TestServiceTestStreamClient, error)
}

type TestServiceTestStreamClient interface {
	grpc.ClientStream
	Send(*TestRequest) error
	Recv() (*TestResponse, error)
}

// Mock service registration.
func RegisterTestServiceServer(_ *grpc.Server, _ TestServiceServer) {
	// In a real implementation, this would be generated by protoc
	// For testing, we'll use a simplified approach
}

type testServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTestServiceClient(cc grpc.ClientConnInterface) TestServiceClient {
	return &testServiceClient{cc}
}

func (c *testServiceClient) TestMethod(ctx context.Context, req *TestRequest, opts ...grpc.CallOption) (*TestResponse, error) {
	out := new(TestResponse)
	err := c.cc.Invoke(ctx, "/test.TestService/TestMethod", req, out, opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to invoke method: %w", err)
	}
	return out, nil
}

func (c *testServiceClient) TestStream(ctx context.Context, opts ...grpc.CallOption) (TestServiceTestStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &grpc.StreamDesc{
		StreamName:    "TestStream",
		ServerStreams: true,
		ClientStreams: true,
	}, "/test.TestService/TestStream", opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to create stream: %w", err)
	}
	return &testStreamClient{stream}, nil
}

type testStreamClient struct {
	grpc.ClientStream
}

func (c *testStreamClient) Send(req *TestRequest) error {
	if err := c.ClientStream.SendMsg(req); err != nil {
		return fmt.Errorf("failed to send message: %w", err)
	}
	return nil
}

func (c *testStreamClient) Recv() (*TestResponse, error) {
	resp := new(TestResponse)
	err := c.ClientStream.RecvMsg(resp)
	if err != nil {
		return nil, fmt.Errorf("failed to receive message: %w", err)
	}
	return resp, nil
}

func bufDialer(lis *bufconn.Listener) func(context.Context, string) (net.Conn, error) {
	return func(_ context.Context, _ string) (net.Conn, error) {
		return lis.Dial()
	}
}

// integrationTestCase defines test cases for integration tests.
type integrationTestCase struct {
	name             string
	setupAuth        bool
	setupPropagation bool
	expectAuth       bool
	expectError      bool
	expectedCode     codes.Code
}

func TestInterceptors_Integration_DISABLED(t *testing.T) {
	t.Skip("Skipping integration test - TLS setup complexity, focus on direct tests")

	tests := []integrationTestCase{
		{
			name:        "no_interceptors",
			expectError: false,
		},
		{
			name:        "auth_enabled_valid_identity",
			setupAuth:   true,
			expectAuth:  true,
			expectError: false,
		},
		{
			name:         "auth_enabled_no_identity",
			setupAuth:    true,
			expectError:  true,
			expectedCode: codes.Unauthenticated,
		},
		{
			name:             "full_interceptor_chain",
			setupAuth:        true,
			setupPropagation: true,
			expectAuth:       true,
			expectError:      false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			runIntegrationTest(t, &tt)
		})
	}
}

// Helper function to run integration test (reduces main function complexity).
func runIntegrationTest(t *testing.T, tc *integrationTestCase) {
	t.Helper()

	ctx, cancel := context.WithTimeout(t.Context(), 5*time.Second)
	defer cancel()

	// Setup test server and client
	_, client, cleanup := setupIntegrationServer(t, tc)
	defer cleanup()

	// Setup client context
	clientCtx := setupClientContext(ctx, tc)

	// Make the call and validate results
	resp, err := client.TestMethod(clientCtx, &TestRequest{Message: "test"})
	validateIntegrationResults(t, tc, resp, err)
}

// Helper function to setup integration server (reduces complexity).
func setupIntegrationServer(t *testing.T, tc *integrationTestCase) (*grpc.Server, TestServiceClient, func()) {
	t.Helper()

	lis := bufconn.Listen(bufSize)
	serverOpts := buildIntegrationServerOptions(tc)
	server := grpc.NewServer(serverOpts...)

	// Register test service
	testSrv := &testServiceImpl{}
	server.RegisterService(&grpc.ServiceDesc{
		ServiceName: "test.TestService",
		HandlerType: (*TestServiceServer)(nil),
		Methods: []grpc.MethodDesc{
			{
				MethodName: "TestMethod",
				Handler: func(srv interface{}, ctx context.Context, dec func(interface{}) error,
					interceptor grpc.UnaryServerInterceptor,
				) (interface{}, error) {
					in := new(TestRequest)
					if err := dec(in); err != nil {
						return nil, err
					}
					if interceptor == nil {
						return testSrv.TestMethod(ctx, in)
					}
					info := &grpc.UnaryServerInfo{
						Server:     srv,
						FullMethod: "/test.TestService/TestMethod",
					}
					handler := func(ctx context.Context, req interface{}) (interface{}, error) {
						return testSrv.TestMethod(ctx, req.(*TestRequest))
					}
					return interceptor(ctx, in, info, handler)
				},
			},
		},
	}, testSrv)

	// Start server
	go func() {
		if err := server.Serve(lis); err != nil {
			t.Logf("Server failed to serve: %v", err)
		}
	}()

	// Setup client
	clientOpts := buildIntegrationClientOptions(tc, lis)
	conn, err := grpc.NewClient("bufnet", clientOpts...)
	require.NoError(t, err)
	client := NewTestServiceClient(conn)

	cleanup := func() {
		conn.Close()
		server.Stop()
	}

	return server, client, cleanup
}

// Helper function to build server options (reduces complexity).
func buildIntegrationServerOptions(tc *integrationTestCase) []grpc.ServerOption {
	var serverOpts []grpc.ServerOption
	if tc.setupAuth {
		authConfig := DefaultAuthConfig()
		authConfig.RequireAuthentication = true
		authInterceptor := NewAuthInterceptor(authConfig)
		serverOpts = append(serverOpts, grpc.UnaryInterceptor(authInterceptor.UnaryServerInterceptor()))
	}
	return serverOpts
}

// Helper function to build client options (reduces complexity).
func buildIntegrationClientOptions(tc *integrationTestCase, lis *bufconn.Listener) []grpc.DialOption {
	clientOpts := []grpc.DialOption{
		grpc.WithContextDialer(bufDialer(lis)),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	}

	if tc.setupPropagation {
		provider := &mockIdentityProvider{
			identity: domain.NewServiceIdentity("test-client", "example.org"),
		}
		identityConfig := DefaultIdentityPropagationConfig(provider)
		propagationInterceptor := NewIdentityPropagationInterceptor(identityConfig)
		clientOpts = append(clientOpts, grpc.WithUnaryInterceptor(propagationInterceptor.UnaryClientInterceptor()))
	}

	return clientOpts
}

// Helper function to setup client context (reduces complexity).
func setupClientContext(ctx context.Context, tc *integrationTestCase) context.Context {
	if tc.expectAuth {
		identity := &AuthenticatedIdentity{
			SPIFFEID:    "spiffe://example.org/test-service",
			ServiceName: "test-service",
			TrustDomain: "example.org",
		}
		return context.WithValue(ctx, IdentityContextKey{}, identity)
	}
	return ctx
}

// Helper function to validate integration test results (reduces complexity).
func validateIntegrationResults(t *testing.T, tc *integrationTestCase, resp *TestResponse, err error) {
	t.Helper()

	if tc.expectError {
		assert.Error(t, err)
		if tc.expectedCode != codes.OK {
			assert.Equal(t, tc.expectedCode, status.Code(err))
		}
		assert.Nil(t, resp)
		return
	}

	assert.NoError(t, err)
	assert.NotNil(t, resp)
	if tc.expectAuth {
		assert.Contains(t, resp.Message, "test-service")
	}
}

func TestAuth_WithHTTPTokenValidation_DISABLED(t *testing.T) {
	t.Skip("Skipping HTTP token validation test - requires different setup than mTLS")

	tests := []struct {
		name           string
		token          string
		serverResponse int
		serverBody     map[string]string
		expectError    bool
		expectedCode   codes.Code
	}{
		{
			name:           "valid_token",
			token:          "Bearer valid-token",
			serverResponse: 200,
			serverBody:     map[string]string{"user": "test-user", "valid": "true"},
			expectError:    false,
		},
		{
			name:           "invalid_token",
			token:          "Bearer invalid-token",
			serverResponse: 401,
			serverBody:     map[string]string{"error": "invalid token"},
			expectError:    true,
			expectedCode:   codes.Unauthenticated,
		},
		{
			name:           "malformed_token",
			token:          "malformed",
			serverResponse: 400,
			serverBody:     map[string]string{"error": "malformed token"},
			expectError:    true,
			expectedCode:   codes.InvalidArgument,
		},
		{
			name:           "server_error",
			token:          "Bearer valid-token",
			serverResponse: 500,
			serverBody:     map[string]string{"error": "internal server error"},
			expectError:    true,
			expectedCode:   codes.Internal,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Mock HTTP token validation server
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				// Verify request format
				assert.Equal(t, "POST", r.Method)
				assert.Equal(t, "application/json", r.Header.Get("Content-Type"))

				token := r.Header.Get("Authorization")
				assert.Equal(t, tt.token, token)

				// Return configured response
				w.WriteHeader(tt.serverResponse)
				w.Header().Set("Content-Type", "application/json")
				json.NewEncoder(w).Encode(tt.serverBody)
			}))
			defer server.Close()

			// Create auth config with HTTP validator
			authConfig := DefaultAuthConfig()
			authConfig.RequireAuthentication = true

			authInterceptor := NewAuthInterceptor(authConfig)

			// Create test context with metadata
			md := metadata.New(map[string]string{
				"authorization": tt.token,
			})
			ctx := metadata.NewIncomingContext(t.Context(), md)

			// Test handler
			handler := func(_ context.Context, _ interface{}) (interface{}, error) {
				return defaultResultCode, nil
			}

			info := &grpc.UnaryServerInfo{
				FullMethod: "/test.Service/TestMethod",
			}

			// Invoke interceptor
			result, err := authInterceptor.UnaryServerInterceptor()(ctx, "request", info, handler)

			// Verify results
			if tt.expectError {
				assert.Error(t, err)
				if tt.expectedCode != codes.OK {
					assert.Equal(t, tt.expectedCode, status.Code(err))
				}
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, "success", result)
			}
		})
	}
}

// Add TokenValidator interface to AuthConfig for this test.
type TokenValidator interface {
	ValidateToken(token string) error
}

// Extend AuthConfig for testing.
type AuthConfigWithValidator struct {
	*AuthConfig
	TokenValidator TokenValidator
}
